// Code generated by github.com/Gardego5/gohtml/codegen; DO NOT EDIT.

package html

import (
	"bytes"
	"io"
	"fmt"
	"slices"
	"strings"
)

func sort(a any, b any) int {
	_, aOk := a.(attr)
	_, bOk := b.(attr)

	if aOk && !bOk {
		return -1
	} else if !aOk && bOk {
		return 1
	} else {
		return 0
	}
}

func index(t any) bool {
	_, ok := t.(attr)
	return !ok
}

func toInt64Error(n int, err error) (int64, error) {
	return int64(n), err
}

// The `a` HTML element (or *anchor* element), with its `href`
// attribute, creates a hyperlink to webpages, files, email
// addresses, locations in the same page, or anything else a URL
// can address.
type A []any

func (tag A) WriteTo(w io.Writer) (int64, error) {
	n := int64(0)

	nn, err := fmt.Fprintf(w, "<a")
	n += int64(nn)
	if err != nil {
		return n, err
	}

	children := len(tag) > 0
	idx := 0

	if children {
		slices.SortStableFunc(tag, sort)
		idx = slices.IndexFunc(tag, index)

		if idx >= 0 {
			for _, attr := range tag[:idx] {
				nn, err := attr.(io.WriterTo).WriteTo(w)
				n += nn
				if err != nil {
					return n, err
				}
			}
		} else {
			for _, attr := range tag {
				nn, err := attr.(io.WriterTo).WriteTo(w)
				n += nn
				if err != nil {
					return n, err
				}
			}
		}
	}

	nn, err = fmt.Fprintf(w, ">")
	n += int64(nn)
	if err != nil {
		return n, err
	}

	if children && idx >= 0 {
		for _, child := range tag[idx:] {
			nn, err := render(w, child)
			n += nn
			if err != nil {
				return n, err
			}
		}
	}

	nn, err = fmt.Fprintf(w, "</a>")
	n += int64(nn)

	return n, nil
}
func (tag A) element() {}
func (tag A) Reader() io.Reader {
	r, w := io.Pipe()
	go func(w *io.PipeWriter) {
		_, err := tag.WriteTo(w)
		if err != nil {
			w.CloseWithError(err)
		} else {
			w.Close()
		}
	}(w)
	return r
}
func (tag A) String() string {
	b := strings.Builder{}
	tag.WriteTo(&b)
	return b.String()
}
func (tag A) Bytes() []byte {
	b := bytes.Buffer{}
	tag.WriteTo(&b)
	return b.Bytes()
}


type Abbr []any

func (tag Abbr) WriteTo(w io.Writer) (int64, error) {
	n := int64(0)

	nn, err := fmt.Fprintf(w, "<abbr")
	n += int64(nn)
	if err != nil {
		return n, err
	}

	children := len(tag) > 0
	idx := 0

	if children {
		slices.SortStableFunc(tag, sort)
		idx = slices.IndexFunc(tag, index)

		if idx >= 0 {
			for _, attr := range tag[:idx] {
				nn, err := attr.(io.WriterTo).WriteTo(w)
				n += nn
				if err != nil {
					return n, err
				}
			}
		} else {
			for _, attr := range tag {
				nn, err := attr.(io.WriterTo).WriteTo(w)
				n += nn
				if err != nil {
					return n, err
				}
			}
		}
	}

	nn, err = fmt.Fprintf(w, ">")
	n += int64(nn)
	if err != nil {
		return n, err
	}

	if children && idx >= 0 {
		for _, child := range tag[idx:] {
			nn, err := render(w, child)
			n += nn
			if err != nil {
				return n, err
			}
		}
	}

	nn, err = fmt.Fprintf(w, "</abbr>")
	n += int64(nn)

	return n, nil
}
func (tag Abbr) element() {}
func (tag Abbr) Reader() io.Reader {
	r, w := io.Pipe()
	go func(w *io.PipeWriter) {
		_, err := tag.WriteTo(w)
		if err != nil {
			w.CloseWithError(err)
		} else {
			w.Close()
		}
	}(w)
	return r
}
func (tag Abbr) String() string {
	b := strings.Builder{}
	tag.WriteTo(&b)
	return b.String()
}
func (tag Abbr) Bytes() []byte {
	b := bytes.Buffer{}
	tag.WriteTo(&b)
	return b.Bytes()
}


type Address []any

func (tag Address) WriteTo(w io.Writer) (int64, error) {
	n := int64(0)

	nn, err := fmt.Fprintf(w, "<address")
	n += int64(nn)
	if err != nil {
		return n, err
	}

	children := len(tag) > 0
	idx := 0

	if children {
		slices.SortStableFunc(tag, sort)
		idx = slices.IndexFunc(tag, index)

		if idx >= 0 {
			for _, attr := range tag[:idx] {
				nn, err := attr.(io.WriterTo).WriteTo(w)
				n += nn
				if err != nil {
					return n, err
				}
			}
		} else {
			for _, attr := range tag {
				nn, err := attr.(io.WriterTo).WriteTo(w)
				n += nn
				if err != nil {
					return n, err
				}
			}
		}
	}

	nn, err = fmt.Fprintf(w, ">")
	n += int64(nn)
	if err != nil {
		return n, err
	}

	if children && idx >= 0 {
		for _, child := range tag[idx:] {
			nn, err := render(w, child)
			n += nn
			if err != nil {
				return n, err
			}
		}
	}

	nn, err = fmt.Fprintf(w, "</address>")
	n += int64(nn)

	return n, nil
}
func (tag Address) element() {}
func (tag Address) Reader() io.Reader {
	r, w := io.Pipe()
	go func(w *io.PipeWriter) {
		_, err := tag.WriteTo(w)
		if err != nil {
			w.CloseWithError(err)
		} else {
			w.Close()
		}
	}(w)
	return r
}
func (tag Address) String() string {
	b := strings.Builder{}
	tag.WriteTo(&b)
	return b.String()
}
func (tag Address) Bytes() []byte {
	b := bytes.Buffer{}
	tag.WriteTo(&b)
	return b.Bytes()
}


type Area baseAttrs

func (tag Area) WriteTo(w io.Writer) (int64, error) {
	n := int64(0)

	nn, err := toInt64Error(fmt.Fprintf(w, "<area"))
	n += int64(nn)
	if err != nil {
		return n, err
	}

	nn, err = baseAttrs(tag).WriteTo(w)
	n += nn
	if err != nil {
		return n, err
	}

	nn, err = toInt64Error(fmt.Fprintf(w, "/>"))
	n += int64(nn)
	return n, err
}
func (tag Area) element() {}
func (tag Area) Reader() io.Reader {
	r, w := io.Pipe()
	go func(w *io.PipeWriter) {
		_, err := tag.WriteTo(w)
		if err != nil {
			w.CloseWithError(err)
		} else {
			w.Close()
		}
	}(w)
	return r
}
func (tag Area) String() string {
	b := strings.Builder{}
	tag.WriteTo(&b)
	return b.String()
}
func (tag Area) Bytes() []byte {
	b := bytes.Buffer{}
	tag.WriteTo(&b)
	return b.Bytes()
}


type Article []any

func (tag Article) WriteTo(w io.Writer) (int64, error) {
	n := int64(0)

	nn, err := fmt.Fprintf(w, "<article")
	n += int64(nn)
	if err != nil {
		return n, err
	}

	children := len(tag) > 0
	idx := 0

	if children {
		slices.SortStableFunc(tag, sort)
		idx = slices.IndexFunc(tag, index)

		if idx >= 0 {
			for _, attr := range tag[:idx] {
				nn, err := attr.(io.WriterTo).WriteTo(w)
				n += nn
				if err != nil {
					return n, err
				}
			}
		} else {
			for _, attr := range tag {
				nn, err := attr.(io.WriterTo).WriteTo(w)
				n += nn
				if err != nil {
					return n, err
				}
			}
		}
	}

	nn, err = fmt.Fprintf(w, ">")
	n += int64(nn)
	if err != nil {
		return n, err
	}

	if children && idx >= 0 {
		for _, child := range tag[idx:] {
			nn, err := render(w, child)
			n += nn
			if err != nil {
				return n, err
			}
		}
	}

	nn, err = fmt.Fprintf(w, "</article>")
	n += int64(nn)

	return n, nil
}
func (tag Article) element() {}
func (tag Article) Reader() io.Reader {
	r, w := io.Pipe()
	go func(w *io.PipeWriter) {
		_, err := tag.WriteTo(w)
		if err != nil {
			w.CloseWithError(err)
		} else {
			w.Close()
		}
	}(w)
	return r
}
func (tag Article) String() string {
	b := strings.Builder{}
	tag.WriteTo(&b)
	return b.String()
}
func (tag Article) Bytes() []byte {
	b := bytes.Buffer{}
	tag.WriteTo(&b)
	return b.Bytes()
}


type Aside []any

func (tag Aside) WriteTo(w io.Writer) (int64, error) {
	n := int64(0)

	nn, err := fmt.Fprintf(w, "<aside")
	n += int64(nn)
	if err != nil {
		return n, err
	}

	children := len(tag) > 0
	idx := 0

	if children {
		slices.SortStableFunc(tag, sort)
		idx = slices.IndexFunc(tag, index)

		if idx >= 0 {
			for _, attr := range tag[:idx] {
				nn, err := attr.(io.WriterTo).WriteTo(w)
				n += nn
				if err != nil {
					return n, err
				}
			}
		} else {
			for _, attr := range tag {
				nn, err := attr.(io.WriterTo).WriteTo(w)
				n += nn
				if err != nil {
					return n, err
				}
			}
		}
	}

	nn, err = fmt.Fprintf(w, ">")
	n += int64(nn)
	if err != nil {
		return n, err
	}

	if children && idx >= 0 {
		for _, child := range tag[idx:] {
			nn, err := render(w, child)
			n += nn
			if err != nil {
				return n, err
			}
		}
	}

	nn, err = fmt.Fprintf(w, "</aside>")
	n += int64(nn)

	return n, nil
}
func (tag Aside) element() {}
func (tag Aside) Reader() io.Reader {
	r, w := io.Pipe()
	go func(w *io.PipeWriter) {
		_, err := tag.WriteTo(w)
		if err != nil {
			w.CloseWithError(err)
		} else {
			w.Close()
		}
	}(w)
	return r
}
func (tag Aside) String() string {
	b := strings.Builder{}
	tag.WriteTo(&b)
	return b.String()
}
func (tag Aside) Bytes() []byte {
	b := bytes.Buffer{}
	tag.WriteTo(&b)
	return b.Bytes()
}


type Audio []any

func (tag Audio) WriteTo(w io.Writer) (int64, error) {
	n := int64(0)

	nn, err := fmt.Fprintf(w, "<audio")
	n += int64(nn)
	if err != nil {
		return n, err
	}

	children := len(tag) > 0
	idx := 0

	if children {
		slices.SortStableFunc(tag, sort)
		idx = slices.IndexFunc(tag, index)

		if idx >= 0 {
			for _, attr := range tag[:idx] {
				nn, err := attr.(io.WriterTo).WriteTo(w)
				n += nn
				if err != nil {
					return n, err
				}
			}
		} else {
			for _, attr := range tag {
				nn, err := attr.(io.WriterTo).WriteTo(w)
				n += nn
				if err != nil {
					return n, err
				}
			}
		}
	}

	nn, err = fmt.Fprintf(w, ">")
	n += int64(nn)
	if err != nil {
		return n, err
	}

	if children && idx >= 0 {
		for _, child := range tag[idx:] {
			nn, err := render(w, child)
			n += nn
			if err != nil {
				return n, err
			}
		}
	}

	nn, err = fmt.Fprintf(w, "</audio>")
	n += int64(nn)

	return n, nil
}
func (tag Audio) element() {}
func (tag Audio) Reader() io.Reader {
	r, w := io.Pipe()
	go func(w *io.PipeWriter) {
		_, err := tag.WriteTo(w)
		if err != nil {
			w.CloseWithError(err)
		} else {
			w.Close()
		}
	}(w)
	return r
}
func (tag Audio) String() string {
	b := strings.Builder{}
	tag.WriteTo(&b)
	return b.String()
}
func (tag Audio) Bytes() []byte {
	b := bytes.Buffer{}
	tag.WriteTo(&b)
	return b.Bytes()
}


type B []any

func (tag B) WriteTo(w io.Writer) (int64, error) {
	n := int64(0)

	nn, err := fmt.Fprintf(w, "<b")
	n += int64(nn)
	if err != nil {
		return n, err
	}

	children := len(tag) > 0
	idx := 0

	if children {
		slices.SortStableFunc(tag, sort)
		idx = slices.IndexFunc(tag, index)

		if idx >= 0 {
			for _, attr := range tag[:idx] {
				nn, err := attr.(io.WriterTo).WriteTo(w)
				n += nn
				if err != nil {
					return n, err
				}
			}
		} else {
			for _, attr := range tag {
				nn, err := attr.(io.WriterTo).WriteTo(w)
				n += nn
				if err != nil {
					return n, err
				}
			}
		}
	}

	nn, err = fmt.Fprintf(w, ">")
	n += int64(nn)
	if err != nil {
		return n, err
	}

	if children && idx >= 0 {
		for _, child := range tag[idx:] {
			nn, err := render(w, child)
			n += nn
			if err != nil {
				return n, err
			}
		}
	}

	nn, err = fmt.Fprintf(w, "</b>")
	n += int64(nn)

	return n, nil
}
func (tag B) element() {}
func (tag B) Reader() io.Reader {
	r, w := io.Pipe()
	go func(w *io.PipeWriter) {
		_, err := tag.WriteTo(w)
		if err != nil {
			w.CloseWithError(err)
		} else {
			w.Close()
		}
	}(w)
	return r
}
func (tag B) String() string {
	b := strings.Builder{}
	tag.WriteTo(&b)
	return b.String()
}
func (tag B) Bytes() []byte {
	b := bytes.Buffer{}
	tag.WriteTo(&b)
	return b.Bytes()
}


type Base baseAttrs

func (tag Base) WriteTo(w io.Writer) (int64, error) {
	n := int64(0)

	nn, err := toInt64Error(fmt.Fprintf(w, "<base"))
	n += int64(nn)
	if err != nil {
		return n, err
	}

	nn, err = baseAttrs(tag).WriteTo(w)
	n += nn
	if err != nil {
		return n, err
	}

	nn, err = toInt64Error(fmt.Fprintf(w, "/>"))
	n += int64(nn)
	return n, err
}
func (tag Base) element() {}
func (tag Base) Reader() io.Reader {
	r, w := io.Pipe()
	go func(w *io.PipeWriter) {
		_, err := tag.WriteTo(w)
		if err != nil {
			w.CloseWithError(err)
		} else {
			w.Close()
		}
	}(w)
	return r
}
func (tag Base) String() string {
	b := strings.Builder{}
	tag.WriteTo(&b)
	return b.String()
}
func (tag Base) Bytes() []byte {
	b := bytes.Buffer{}
	tag.WriteTo(&b)
	return b.Bytes()
}


type Bdi []any

func (tag Bdi) WriteTo(w io.Writer) (int64, error) {
	n := int64(0)

	nn, err := fmt.Fprintf(w, "<bdi")
	n += int64(nn)
	if err != nil {
		return n, err
	}

	children := len(tag) > 0
	idx := 0

	if children {
		slices.SortStableFunc(tag, sort)
		idx = slices.IndexFunc(tag, index)

		if idx >= 0 {
			for _, attr := range tag[:idx] {
				nn, err := attr.(io.WriterTo).WriteTo(w)
				n += nn
				if err != nil {
					return n, err
				}
			}
		} else {
			for _, attr := range tag {
				nn, err := attr.(io.WriterTo).WriteTo(w)
				n += nn
				if err != nil {
					return n, err
				}
			}
		}
	}

	nn, err = fmt.Fprintf(w, ">")
	n += int64(nn)
	if err != nil {
		return n, err
	}

	if children && idx >= 0 {
		for _, child := range tag[idx:] {
			nn, err := render(w, child)
			n += nn
			if err != nil {
				return n, err
			}
		}
	}

	nn, err = fmt.Fprintf(w, "</bdi>")
	n += int64(nn)

	return n, nil
}
func (tag Bdi) element() {}
func (tag Bdi) Reader() io.Reader {
	r, w := io.Pipe()
	go func(w *io.PipeWriter) {
		_, err := tag.WriteTo(w)
		if err != nil {
			w.CloseWithError(err)
		} else {
			w.Close()
		}
	}(w)
	return r
}
func (tag Bdi) String() string {
	b := strings.Builder{}
	tag.WriteTo(&b)
	return b.String()
}
func (tag Bdi) Bytes() []byte {
	b := bytes.Buffer{}
	tag.WriteTo(&b)
	return b.Bytes()
}


type Bdo []any

func (tag Bdo) WriteTo(w io.Writer) (int64, error) {
	n := int64(0)

	nn, err := fmt.Fprintf(w, "<bdo")
	n += int64(nn)
	if err != nil {
		return n, err
	}

	children := len(tag) > 0
	idx := 0

	if children {
		slices.SortStableFunc(tag, sort)
		idx = slices.IndexFunc(tag, index)

		if idx >= 0 {
			for _, attr := range tag[:idx] {
				nn, err := attr.(io.WriterTo).WriteTo(w)
				n += nn
				if err != nil {
					return n, err
				}
			}
		} else {
			for _, attr := range tag {
				nn, err := attr.(io.WriterTo).WriteTo(w)
				n += nn
				if err != nil {
					return n, err
				}
			}
		}
	}

	nn, err = fmt.Fprintf(w, ">")
	n += int64(nn)
	if err != nil {
		return n, err
	}

	if children && idx >= 0 {
		for _, child := range tag[idx:] {
			nn, err := render(w, child)
			n += nn
			if err != nil {
				return n, err
			}
		}
	}

	nn, err = fmt.Fprintf(w, "</bdo>")
	n += int64(nn)

	return n, nil
}
func (tag Bdo) element() {}
func (tag Bdo) Reader() io.Reader {
	r, w := io.Pipe()
	go func(w *io.PipeWriter) {
		_, err := tag.WriteTo(w)
		if err != nil {
			w.CloseWithError(err)
		} else {
			w.Close()
		}
	}(w)
	return r
}
func (tag Bdo) String() string {
	b := strings.Builder{}
	tag.WriteTo(&b)
	return b.String()
}
func (tag Bdo) Bytes() []byte {
	b := bytes.Buffer{}
	tag.WriteTo(&b)
	return b.Bytes()
}


type Blockquote []any

func (tag Blockquote) WriteTo(w io.Writer) (int64, error) {
	n := int64(0)

	nn, err := fmt.Fprintf(w, "<blockquote")
	n += int64(nn)
	if err != nil {
		return n, err
	}

	children := len(tag) > 0
	idx := 0

	if children {
		slices.SortStableFunc(tag, sort)
		idx = slices.IndexFunc(tag, index)

		if idx >= 0 {
			for _, attr := range tag[:idx] {
				nn, err := attr.(io.WriterTo).WriteTo(w)
				n += nn
				if err != nil {
					return n, err
				}
			}
		} else {
			for _, attr := range tag {
				nn, err := attr.(io.WriterTo).WriteTo(w)
				n += nn
				if err != nil {
					return n, err
				}
			}
		}
	}

	nn, err = fmt.Fprintf(w, ">")
	n += int64(nn)
	if err != nil {
		return n, err
	}

	if children && idx >= 0 {
		for _, child := range tag[idx:] {
			nn, err := render(w, child)
			n += nn
			if err != nil {
				return n, err
			}
		}
	}

	nn, err = fmt.Fprintf(w, "</blockquote>")
	n += int64(nn)

	return n, nil
}
func (tag Blockquote) element() {}
func (tag Blockquote) Reader() io.Reader {
	r, w := io.Pipe()
	go func(w *io.PipeWriter) {
		_, err := tag.WriteTo(w)
		if err != nil {
			w.CloseWithError(err)
		} else {
			w.Close()
		}
	}(w)
	return r
}
func (tag Blockquote) String() string {
	b := strings.Builder{}
	tag.WriteTo(&b)
	return b.String()
}
func (tag Blockquote) Bytes() []byte {
	b := bytes.Buffer{}
	tag.WriteTo(&b)
	return b.Bytes()
}


type Body []any

func (tag Body) WriteTo(w io.Writer) (int64, error) {
	n := int64(0)

	nn, err := fmt.Fprintf(w, "<body")
	n += int64(nn)
	if err != nil {
		return n, err
	}

	children := len(tag) > 0
	idx := 0

	if children {
		slices.SortStableFunc(tag, sort)
		idx = slices.IndexFunc(tag, index)

		if idx >= 0 {
			for _, attr := range tag[:idx] {
				nn, err := attr.(io.WriterTo).WriteTo(w)
				n += nn
				if err != nil {
					return n, err
				}
			}
		} else {
			for _, attr := range tag {
				nn, err := attr.(io.WriterTo).WriteTo(w)
				n += nn
				if err != nil {
					return n, err
				}
			}
		}
	}

	nn, err = fmt.Fprintf(w, ">")
	n += int64(nn)
	if err != nil {
		return n, err
	}

	if children && idx >= 0 {
		for _, child := range tag[idx:] {
			nn, err := render(w, child)
			n += nn
			if err != nil {
				return n, err
			}
		}
	}

	nn, err = fmt.Fprintf(w, "</body>")
	n += int64(nn)

	return n, nil
}
func (tag Body) element() {}
func (tag Body) Reader() io.Reader {
	r, w := io.Pipe()
	go func(w *io.PipeWriter) {
		_, err := tag.WriteTo(w)
		if err != nil {
			w.CloseWithError(err)
		} else {
			w.Close()
		}
	}(w)
	return r
}
func (tag Body) String() string {
	b := strings.Builder{}
	tag.WriteTo(&b)
	return b.String()
}
func (tag Body) Bytes() []byte {
	b := bytes.Buffer{}
	tag.WriteTo(&b)
	return b.Bytes()
}


type Br baseAttrs

func (tag Br) WriteTo(w io.Writer) (int64, error) {
	n := int64(0)

	nn, err := toInt64Error(fmt.Fprintf(w, "<br"))
	n += int64(nn)
	if err != nil {
		return n, err
	}

	nn, err = baseAttrs(tag).WriteTo(w)
	n += nn
	if err != nil {
		return n, err
	}

	nn, err = toInt64Error(fmt.Fprintf(w, "/>"))
	n += int64(nn)
	return n, err
}
func (tag Br) element() {}
func (tag Br) Reader() io.Reader {
	r, w := io.Pipe()
	go func(w *io.PipeWriter) {
		_, err := tag.WriteTo(w)
		if err != nil {
			w.CloseWithError(err)
		} else {
			w.Close()
		}
	}(w)
	return r
}
func (tag Br) String() string {
	b := strings.Builder{}
	tag.WriteTo(&b)
	return b.String()
}
func (tag Br) Bytes() []byte {
	b := bytes.Buffer{}
	tag.WriteTo(&b)
	return b.Bytes()
}


type Button []any

func (tag Button) WriteTo(w io.Writer) (int64, error) {
	n := int64(0)

	nn, err := fmt.Fprintf(w, "<button")
	n += int64(nn)
	if err != nil {
		return n, err
	}

	children := len(tag) > 0
	idx := 0

	if children {
		slices.SortStableFunc(tag, sort)
		idx = slices.IndexFunc(tag, index)

		if idx >= 0 {
			for _, attr := range tag[:idx] {
				nn, err := attr.(io.WriterTo).WriteTo(w)
				n += nn
				if err != nil {
					return n, err
				}
			}
		} else {
			for _, attr := range tag {
				nn, err := attr.(io.WriterTo).WriteTo(w)
				n += nn
				if err != nil {
					return n, err
				}
			}
		}
	}

	nn, err = fmt.Fprintf(w, ">")
	n += int64(nn)
	if err != nil {
		return n, err
	}

	if children && idx >= 0 {
		for _, child := range tag[idx:] {
			nn, err := render(w, child)
			n += nn
			if err != nil {
				return n, err
			}
		}
	}

	nn, err = fmt.Fprintf(w, "</button>")
	n += int64(nn)

	return n, nil
}
func (tag Button) element() {}
func (tag Button) Reader() io.Reader {
	r, w := io.Pipe()
	go func(w *io.PipeWriter) {
		_, err := tag.WriteTo(w)
		if err != nil {
			w.CloseWithError(err)
		} else {
			w.Close()
		}
	}(w)
	return r
}
func (tag Button) String() string {
	b := strings.Builder{}
	tag.WriteTo(&b)
	return b.String()
}
func (tag Button) Bytes() []byte {
	b := bytes.Buffer{}
	tag.WriteTo(&b)
	return b.Bytes()
}


type Canvas []any

func (tag Canvas) WriteTo(w io.Writer) (int64, error) {
	n := int64(0)

	nn, err := fmt.Fprintf(w, "<canvas")
	n += int64(nn)
	if err != nil {
		return n, err
	}

	children := len(tag) > 0
	idx := 0

	if children {
		slices.SortStableFunc(tag, sort)
		idx = slices.IndexFunc(tag, index)

		if idx >= 0 {
			for _, attr := range tag[:idx] {
				nn, err := attr.(io.WriterTo).WriteTo(w)
				n += nn
				if err != nil {
					return n, err
				}
			}
		} else {
			for _, attr := range tag {
				nn, err := attr.(io.WriterTo).WriteTo(w)
				n += nn
				if err != nil {
					return n, err
				}
			}
		}
	}

	nn, err = fmt.Fprintf(w, ">")
	n += int64(nn)
	if err != nil {
		return n, err
	}

	if children && idx >= 0 {
		for _, child := range tag[idx:] {
			nn, err := render(w, child)
			n += nn
			if err != nil {
				return n, err
			}
		}
	}

	nn, err = fmt.Fprintf(w, "</canvas>")
	n += int64(nn)

	return n, nil
}
func (tag Canvas) element() {}
func (tag Canvas) Reader() io.Reader {
	r, w := io.Pipe()
	go func(w *io.PipeWriter) {
		_, err := tag.WriteTo(w)
		if err != nil {
			w.CloseWithError(err)
		} else {
			w.Close()
		}
	}(w)
	return r
}
func (tag Canvas) String() string {
	b := strings.Builder{}
	tag.WriteTo(&b)
	return b.String()
}
func (tag Canvas) Bytes() []byte {
	b := bytes.Buffer{}
	tag.WriteTo(&b)
	return b.Bytes()
}


type Caption []any

func (tag Caption) WriteTo(w io.Writer) (int64, error) {
	n := int64(0)

	nn, err := fmt.Fprintf(w, "<caption")
	n += int64(nn)
	if err != nil {
		return n, err
	}

	children := len(tag) > 0
	idx := 0

	if children {
		slices.SortStableFunc(tag, sort)
		idx = slices.IndexFunc(tag, index)

		if idx >= 0 {
			for _, attr := range tag[:idx] {
				nn, err := attr.(io.WriterTo).WriteTo(w)
				n += nn
				if err != nil {
					return n, err
				}
			}
		} else {
			for _, attr := range tag {
				nn, err := attr.(io.WriterTo).WriteTo(w)
				n += nn
				if err != nil {
					return n, err
				}
			}
		}
	}

	nn, err = fmt.Fprintf(w, ">")
	n += int64(nn)
	if err != nil {
		return n, err
	}

	if children && idx >= 0 {
		for _, child := range tag[idx:] {
			nn, err := render(w, child)
			n += nn
			if err != nil {
				return n, err
			}
		}
	}

	nn, err = fmt.Fprintf(w, "</caption>")
	n += int64(nn)

	return n, nil
}
func (tag Caption) element() {}
func (tag Caption) Reader() io.Reader {
	r, w := io.Pipe()
	go func(w *io.PipeWriter) {
		_, err := tag.WriteTo(w)
		if err != nil {
			w.CloseWithError(err)
		} else {
			w.Close()
		}
	}(w)
	return r
}
func (tag Caption) String() string {
	b := strings.Builder{}
	tag.WriteTo(&b)
	return b.String()
}
func (tag Caption) Bytes() []byte {
	b := bytes.Buffer{}
	tag.WriteTo(&b)
	return b.Bytes()
}


type Cite []any

func (tag Cite) WriteTo(w io.Writer) (int64, error) {
	n := int64(0)

	nn, err := fmt.Fprintf(w, "<cite")
	n += int64(nn)
	if err != nil {
		return n, err
	}

	children := len(tag) > 0
	idx := 0

	if children {
		slices.SortStableFunc(tag, sort)
		idx = slices.IndexFunc(tag, index)

		if idx >= 0 {
			for _, attr := range tag[:idx] {
				nn, err := attr.(io.WriterTo).WriteTo(w)
				n += nn
				if err != nil {
					return n, err
				}
			}
		} else {
			for _, attr := range tag {
				nn, err := attr.(io.WriterTo).WriteTo(w)
				n += nn
				if err != nil {
					return n, err
				}
			}
		}
	}

	nn, err = fmt.Fprintf(w, ">")
	n += int64(nn)
	if err != nil {
		return n, err
	}

	if children && idx >= 0 {
		for _, child := range tag[idx:] {
			nn, err := render(w, child)
			n += nn
			if err != nil {
				return n, err
			}
		}
	}

	nn, err = fmt.Fprintf(w, "</cite>")
	n += int64(nn)

	return n, nil
}
func (tag Cite) element() {}
func (tag Cite) Reader() io.Reader {
	r, w := io.Pipe()
	go func(w *io.PipeWriter) {
		_, err := tag.WriteTo(w)
		if err != nil {
			w.CloseWithError(err)
		} else {
			w.Close()
		}
	}(w)
	return r
}
func (tag Cite) String() string {
	b := strings.Builder{}
	tag.WriteTo(&b)
	return b.String()
}
func (tag Cite) Bytes() []byte {
	b := bytes.Buffer{}
	tag.WriteTo(&b)
	return b.Bytes()
}


type Code []any

func (tag Code) WriteTo(w io.Writer) (int64, error) {
	n := int64(0)

	nn, err := fmt.Fprintf(w, "<code")
	n += int64(nn)
	if err != nil {
		return n, err
	}

	children := len(tag) > 0
	idx := 0

	if children {
		slices.SortStableFunc(tag, sort)
		idx = slices.IndexFunc(tag, index)

		if idx >= 0 {
			for _, attr := range tag[:idx] {
				nn, err := attr.(io.WriterTo).WriteTo(w)
				n += nn
				if err != nil {
					return n, err
				}
			}
		} else {
			for _, attr := range tag {
				nn, err := attr.(io.WriterTo).WriteTo(w)
				n += nn
				if err != nil {
					return n, err
				}
			}
		}
	}

	nn, err = fmt.Fprintf(w, ">")
	n += int64(nn)
	if err != nil {
		return n, err
	}

	if children && idx >= 0 {
		for _, child := range tag[idx:] {
			nn, err := render(w, child)
			n += nn
			if err != nil {
				return n, err
			}
		}
	}

	nn, err = fmt.Fprintf(w, "</code>")
	n += int64(nn)

	return n, nil
}
func (tag Code) element() {}
func (tag Code) Reader() io.Reader {
	r, w := io.Pipe()
	go func(w *io.PipeWriter) {
		_, err := tag.WriteTo(w)
		if err != nil {
			w.CloseWithError(err)
		} else {
			w.Close()
		}
	}(w)
	return r
}
func (tag Code) String() string {
	b := strings.Builder{}
	tag.WriteTo(&b)
	return b.String()
}
func (tag Code) Bytes() []byte {
	b := bytes.Buffer{}
	tag.WriteTo(&b)
	return b.Bytes()
}


type Col baseAttrs

func (tag Col) WriteTo(w io.Writer) (int64, error) {
	n := int64(0)

	nn, err := toInt64Error(fmt.Fprintf(w, "<col"))
	n += int64(nn)
	if err != nil {
		return n, err
	}

	nn, err = baseAttrs(tag).WriteTo(w)
	n += nn
	if err != nil {
		return n, err
	}

	nn, err = toInt64Error(fmt.Fprintf(w, "/>"))
	n += int64(nn)
	return n, err
}
func (tag Col) element() {}
func (tag Col) Reader() io.Reader {
	r, w := io.Pipe()
	go func(w *io.PipeWriter) {
		_, err := tag.WriteTo(w)
		if err != nil {
			w.CloseWithError(err)
		} else {
			w.Close()
		}
	}(w)
	return r
}
func (tag Col) String() string {
	b := strings.Builder{}
	tag.WriteTo(&b)
	return b.String()
}
func (tag Col) Bytes() []byte {
	b := bytes.Buffer{}
	tag.WriteTo(&b)
	return b.Bytes()
}


type Colgroup []any

func (tag Colgroup) WriteTo(w io.Writer) (int64, error) {
	n := int64(0)

	nn, err := fmt.Fprintf(w, "<colgroup")
	n += int64(nn)
	if err != nil {
		return n, err
	}

	children := len(tag) > 0
	idx := 0

	if children {
		slices.SortStableFunc(tag, sort)
		idx = slices.IndexFunc(tag, index)

		if idx >= 0 {
			for _, attr := range tag[:idx] {
				nn, err := attr.(io.WriterTo).WriteTo(w)
				n += nn
				if err != nil {
					return n, err
				}
			}
		} else {
			for _, attr := range tag {
				nn, err := attr.(io.WriterTo).WriteTo(w)
				n += nn
				if err != nil {
					return n, err
				}
			}
		}
	}

	nn, err = fmt.Fprintf(w, ">")
	n += int64(nn)
	if err != nil {
		return n, err
	}

	if children && idx >= 0 {
		for _, child := range tag[idx:] {
			nn, err := render(w, child)
			n += nn
			if err != nil {
				return n, err
			}
		}
	}

	nn, err = fmt.Fprintf(w, "</colgroup>")
	n += int64(nn)

	return n, nil
}
func (tag Colgroup) element() {}
func (tag Colgroup) Reader() io.Reader {
	r, w := io.Pipe()
	go func(w *io.PipeWriter) {
		_, err := tag.WriteTo(w)
		if err != nil {
			w.CloseWithError(err)
		} else {
			w.Close()
		}
	}(w)
	return r
}
func (tag Colgroup) String() string {
	b := strings.Builder{}
	tag.WriteTo(&b)
	return b.String()
}
func (tag Colgroup) Bytes() []byte {
	b := bytes.Buffer{}
	tag.WriteTo(&b)
	return b.Bytes()
}


type Data []any

func (tag Data) WriteTo(w io.Writer) (int64, error) {
	n := int64(0)

	nn, err := fmt.Fprintf(w, "<data")
	n += int64(nn)
	if err != nil {
		return n, err
	}

	children := len(tag) > 0
	idx := 0

	if children {
		slices.SortStableFunc(tag, sort)
		idx = slices.IndexFunc(tag, index)

		if idx >= 0 {
			for _, attr := range tag[:idx] {
				nn, err := attr.(io.WriterTo).WriteTo(w)
				n += nn
				if err != nil {
					return n, err
				}
			}
		} else {
			for _, attr := range tag {
				nn, err := attr.(io.WriterTo).WriteTo(w)
				n += nn
				if err != nil {
					return n, err
				}
			}
		}
	}

	nn, err = fmt.Fprintf(w, ">")
	n += int64(nn)
	if err != nil {
		return n, err
	}

	if children && idx >= 0 {
		for _, child := range tag[idx:] {
			nn, err := render(w, child)
			n += nn
			if err != nil {
				return n, err
			}
		}
	}

	nn, err = fmt.Fprintf(w, "</data>")
	n += int64(nn)

	return n, nil
}
func (tag Data) element() {}
func (tag Data) Reader() io.Reader {
	r, w := io.Pipe()
	go func(w *io.PipeWriter) {
		_, err := tag.WriteTo(w)
		if err != nil {
			w.CloseWithError(err)
		} else {
			w.Close()
		}
	}(w)
	return r
}
func (tag Data) String() string {
	b := strings.Builder{}
	tag.WriteTo(&b)
	return b.String()
}
func (tag Data) Bytes() []byte {
	b := bytes.Buffer{}
	tag.WriteTo(&b)
	return b.Bytes()
}


type Datalist []any

func (tag Datalist) WriteTo(w io.Writer) (int64, error) {
	n := int64(0)

	nn, err := fmt.Fprintf(w, "<datalist")
	n += int64(nn)
	if err != nil {
		return n, err
	}

	children := len(tag) > 0
	idx := 0

	if children {
		slices.SortStableFunc(tag, sort)
		idx = slices.IndexFunc(tag, index)

		if idx >= 0 {
			for _, attr := range tag[:idx] {
				nn, err := attr.(io.WriterTo).WriteTo(w)
				n += nn
				if err != nil {
					return n, err
				}
			}
		} else {
			for _, attr := range tag {
				nn, err := attr.(io.WriterTo).WriteTo(w)
				n += nn
				if err != nil {
					return n, err
				}
			}
		}
	}

	nn, err = fmt.Fprintf(w, ">")
	n += int64(nn)
	if err != nil {
		return n, err
	}

	if children && idx >= 0 {
		for _, child := range tag[idx:] {
			nn, err := render(w, child)
			n += nn
			if err != nil {
				return n, err
			}
		}
	}

	nn, err = fmt.Fprintf(w, "</datalist>")
	n += int64(nn)

	return n, nil
}
func (tag Datalist) element() {}
func (tag Datalist) Reader() io.Reader {
	r, w := io.Pipe()
	go func(w *io.PipeWriter) {
		_, err := tag.WriteTo(w)
		if err != nil {
			w.CloseWithError(err)
		} else {
			w.Close()
		}
	}(w)
	return r
}
func (tag Datalist) String() string {
	b := strings.Builder{}
	tag.WriteTo(&b)
	return b.String()
}
func (tag Datalist) Bytes() []byte {
	b := bytes.Buffer{}
	tag.WriteTo(&b)
	return b.Bytes()
}


type Dd []any

func (tag Dd) WriteTo(w io.Writer) (int64, error) {
	n := int64(0)

	nn, err := fmt.Fprintf(w, "<dd")
	n += int64(nn)
	if err != nil {
		return n, err
	}

	children := len(tag) > 0
	idx := 0

	if children {
		slices.SortStableFunc(tag, sort)
		idx = slices.IndexFunc(tag, index)

		if idx >= 0 {
			for _, attr := range tag[:idx] {
				nn, err := attr.(io.WriterTo).WriteTo(w)
				n += nn
				if err != nil {
					return n, err
				}
			}
		} else {
			for _, attr := range tag {
				nn, err := attr.(io.WriterTo).WriteTo(w)
				n += nn
				if err != nil {
					return n, err
				}
			}
		}
	}

	nn, err = fmt.Fprintf(w, ">")
	n += int64(nn)
	if err != nil {
		return n, err
	}

	if children && idx >= 0 {
		for _, child := range tag[idx:] {
			nn, err := render(w, child)
			n += nn
			if err != nil {
				return n, err
			}
		}
	}

	nn, err = fmt.Fprintf(w, "</dd>")
	n += int64(nn)

	return n, nil
}
func (tag Dd) element() {}
func (tag Dd) Reader() io.Reader {
	r, w := io.Pipe()
	go func(w *io.PipeWriter) {
		_, err := tag.WriteTo(w)
		if err != nil {
			w.CloseWithError(err)
		} else {
			w.Close()
		}
	}(w)
	return r
}
func (tag Dd) String() string {
	b := strings.Builder{}
	tag.WriteTo(&b)
	return b.String()
}
func (tag Dd) Bytes() []byte {
	b := bytes.Buffer{}
	tag.WriteTo(&b)
	return b.Bytes()
}


type Del []any

func (tag Del) WriteTo(w io.Writer) (int64, error) {
	n := int64(0)

	nn, err := fmt.Fprintf(w, "<del")
	n += int64(nn)
	if err != nil {
		return n, err
	}

	children := len(tag) > 0
	idx := 0

	if children {
		slices.SortStableFunc(tag, sort)
		idx = slices.IndexFunc(tag, index)

		if idx >= 0 {
			for _, attr := range tag[:idx] {
				nn, err := attr.(io.WriterTo).WriteTo(w)
				n += nn
				if err != nil {
					return n, err
				}
			}
		} else {
			for _, attr := range tag {
				nn, err := attr.(io.WriterTo).WriteTo(w)
				n += nn
				if err != nil {
					return n, err
				}
			}
		}
	}

	nn, err = fmt.Fprintf(w, ">")
	n += int64(nn)
	if err != nil {
		return n, err
	}

	if children && idx >= 0 {
		for _, child := range tag[idx:] {
			nn, err := render(w, child)
			n += nn
			if err != nil {
				return n, err
			}
		}
	}

	nn, err = fmt.Fprintf(w, "</del>")
	n += int64(nn)

	return n, nil
}
func (tag Del) element() {}
func (tag Del) Reader() io.Reader {
	r, w := io.Pipe()
	go func(w *io.PipeWriter) {
		_, err := tag.WriteTo(w)
		if err != nil {
			w.CloseWithError(err)
		} else {
			w.Close()
		}
	}(w)
	return r
}
func (tag Del) String() string {
	b := strings.Builder{}
	tag.WriteTo(&b)
	return b.String()
}
func (tag Del) Bytes() []byte {
	b := bytes.Buffer{}
	tag.WriteTo(&b)
	return b.Bytes()
}


type Details []any

func (tag Details) WriteTo(w io.Writer) (int64, error) {
	n := int64(0)

	nn, err := fmt.Fprintf(w, "<details")
	n += int64(nn)
	if err != nil {
		return n, err
	}

	children := len(tag) > 0
	idx := 0

	if children {
		slices.SortStableFunc(tag, sort)
		idx = slices.IndexFunc(tag, index)

		if idx >= 0 {
			for _, attr := range tag[:idx] {
				nn, err := attr.(io.WriterTo).WriteTo(w)
				n += nn
				if err != nil {
					return n, err
				}
			}
		} else {
			for _, attr := range tag {
				nn, err := attr.(io.WriterTo).WriteTo(w)
				n += nn
				if err != nil {
					return n, err
				}
			}
		}
	}

	nn, err = fmt.Fprintf(w, ">")
	n += int64(nn)
	if err != nil {
		return n, err
	}

	if children && idx >= 0 {
		for _, child := range tag[idx:] {
			nn, err := render(w, child)
			n += nn
			if err != nil {
				return n, err
			}
		}
	}

	nn, err = fmt.Fprintf(w, "</details>")
	n += int64(nn)

	return n, nil
}
func (tag Details) element() {}
func (tag Details) Reader() io.Reader {
	r, w := io.Pipe()
	go func(w *io.PipeWriter) {
		_, err := tag.WriteTo(w)
		if err != nil {
			w.CloseWithError(err)
		} else {
			w.Close()
		}
	}(w)
	return r
}
func (tag Details) String() string {
	b := strings.Builder{}
	tag.WriteTo(&b)
	return b.String()
}
func (tag Details) Bytes() []byte {
	b := bytes.Buffer{}
	tag.WriteTo(&b)
	return b.Bytes()
}


type Dfn []any

func (tag Dfn) WriteTo(w io.Writer) (int64, error) {
	n := int64(0)

	nn, err := fmt.Fprintf(w, "<dfn")
	n += int64(nn)
	if err != nil {
		return n, err
	}

	children := len(tag) > 0
	idx := 0

	if children {
		slices.SortStableFunc(tag, sort)
		idx = slices.IndexFunc(tag, index)

		if idx >= 0 {
			for _, attr := range tag[:idx] {
				nn, err := attr.(io.WriterTo).WriteTo(w)
				n += nn
				if err != nil {
					return n, err
				}
			}
		} else {
			for _, attr := range tag {
				nn, err := attr.(io.WriterTo).WriteTo(w)
				n += nn
				if err != nil {
					return n, err
				}
			}
		}
	}

	nn, err = fmt.Fprintf(w, ">")
	n += int64(nn)
	if err != nil {
		return n, err
	}

	if children && idx >= 0 {
		for _, child := range tag[idx:] {
			nn, err := render(w, child)
			n += nn
			if err != nil {
				return n, err
			}
		}
	}

	nn, err = fmt.Fprintf(w, "</dfn>")
	n += int64(nn)

	return n, nil
}
func (tag Dfn) element() {}
func (tag Dfn) Reader() io.Reader {
	r, w := io.Pipe()
	go func(w *io.PipeWriter) {
		_, err := tag.WriteTo(w)
		if err != nil {
			w.CloseWithError(err)
		} else {
			w.Close()
		}
	}(w)
	return r
}
func (tag Dfn) String() string {
	b := strings.Builder{}
	tag.WriteTo(&b)
	return b.String()
}
func (tag Dfn) Bytes() []byte {
	b := bytes.Buffer{}
	tag.WriteTo(&b)
	return b.Bytes()
}


type Dialog []any

func (tag Dialog) WriteTo(w io.Writer) (int64, error) {
	n := int64(0)

	nn, err := fmt.Fprintf(w, "<dialog")
	n += int64(nn)
	if err != nil {
		return n, err
	}

	children := len(tag) > 0
	idx := 0

	if children {
		slices.SortStableFunc(tag, sort)
		idx = slices.IndexFunc(tag, index)

		if idx >= 0 {
			for _, attr := range tag[:idx] {
				nn, err := attr.(io.WriterTo).WriteTo(w)
				n += nn
				if err != nil {
					return n, err
				}
			}
		} else {
			for _, attr := range tag {
				nn, err := attr.(io.WriterTo).WriteTo(w)
				n += nn
				if err != nil {
					return n, err
				}
			}
		}
	}

	nn, err = fmt.Fprintf(w, ">")
	n += int64(nn)
	if err != nil {
		return n, err
	}

	if children && idx >= 0 {
		for _, child := range tag[idx:] {
			nn, err := render(w, child)
			n += nn
			if err != nil {
				return n, err
			}
		}
	}

	nn, err = fmt.Fprintf(w, "</dialog>")
	n += int64(nn)

	return n, nil
}
func (tag Dialog) element() {}
func (tag Dialog) Reader() io.Reader {
	r, w := io.Pipe()
	go func(w *io.PipeWriter) {
		_, err := tag.WriteTo(w)
		if err != nil {
			w.CloseWithError(err)
		} else {
			w.Close()
		}
	}(w)
	return r
}
func (tag Dialog) String() string {
	b := strings.Builder{}
	tag.WriteTo(&b)
	return b.String()
}
func (tag Dialog) Bytes() []byte {
	b := bytes.Buffer{}
	tag.WriteTo(&b)
	return b.Bytes()
}


type Div []any

func (tag Div) WriteTo(w io.Writer) (int64, error) {
	n := int64(0)

	nn, err := fmt.Fprintf(w, "<div")
	n += int64(nn)
	if err != nil {
		return n, err
	}

	children := len(tag) > 0
	idx := 0

	if children {
		slices.SortStableFunc(tag, sort)
		idx = slices.IndexFunc(tag, index)

		if idx >= 0 {
			for _, attr := range tag[:idx] {
				nn, err := attr.(io.WriterTo).WriteTo(w)
				n += nn
				if err != nil {
					return n, err
				}
			}
		} else {
			for _, attr := range tag {
				nn, err := attr.(io.WriterTo).WriteTo(w)
				n += nn
				if err != nil {
					return n, err
				}
			}
		}
	}

	nn, err = fmt.Fprintf(w, ">")
	n += int64(nn)
	if err != nil {
		return n, err
	}

	if children && idx >= 0 {
		for _, child := range tag[idx:] {
			nn, err := render(w, child)
			n += nn
			if err != nil {
				return n, err
			}
		}
	}

	nn, err = fmt.Fprintf(w, "</div>")
	n += int64(nn)

	return n, nil
}
func (tag Div) element() {}
func (tag Div) Reader() io.Reader {
	r, w := io.Pipe()
	go func(w *io.PipeWriter) {
		_, err := tag.WriteTo(w)
		if err != nil {
			w.CloseWithError(err)
		} else {
			w.Close()
		}
	}(w)
	return r
}
func (tag Div) String() string {
	b := strings.Builder{}
	tag.WriteTo(&b)
	return b.String()
}
func (tag Div) Bytes() []byte {
	b := bytes.Buffer{}
	tag.WriteTo(&b)
	return b.Bytes()
}


type Dl []any

func (tag Dl) WriteTo(w io.Writer) (int64, error) {
	n := int64(0)

	nn, err := fmt.Fprintf(w, "<dl")
	n += int64(nn)
	if err != nil {
		return n, err
	}

	children := len(tag) > 0
	idx := 0

	if children {
		slices.SortStableFunc(tag, sort)
		idx = slices.IndexFunc(tag, index)

		if idx >= 0 {
			for _, attr := range tag[:idx] {
				nn, err := attr.(io.WriterTo).WriteTo(w)
				n += nn
				if err != nil {
					return n, err
				}
			}
		} else {
			for _, attr := range tag {
				nn, err := attr.(io.WriterTo).WriteTo(w)
				n += nn
				if err != nil {
					return n, err
				}
			}
		}
	}

	nn, err = fmt.Fprintf(w, ">")
	n += int64(nn)
	if err != nil {
		return n, err
	}

	if children && idx >= 0 {
		for _, child := range tag[idx:] {
			nn, err := render(w, child)
			n += nn
			if err != nil {
				return n, err
			}
		}
	}

	nn, err = fmt.Fprintf(w, "</dl>")
	n += int64(nn)

	return n, nil
}
func (tag Dl) element() {}
func (tag Dl) Reader() io.Reader {
	r, w := io.Pipe()
	go func(w *io.PipeWriter) {
		_, err := tag.WriteTo(w)
		if err != nil {
			w.CloseWithError(err)
		} else {
			w.Close()
		}
	}(w)
	return r
}
func (tag Dl) String() string {
	b := strings.Builder{}
	tag.WriteTo(&b)
	return b.String()
}
func (tag Dl) Bytes() []byte {
	b := bytes.Buffer{}
	tag.WriteTo(&b)
	return b.Bytes()
}


type Dt []any

func (tag Dt) WriteTo(w io.Writer) (int64, error) {
	n := int64(0)

	nn, err := fmt.Fprintf(w, "<dt")
	n += int64(nn)
	if err != nil {
		return n, err
	}

	children := len(tag) > 0
	idx := 0

	if children {
		slices.SortStableFunc(tag, sort)
		idx = slices.IndexFunc(tag, index)

		if idx >= 0 {
			for _, attr := range tag[:idx] {
				nn, err := attr.(io.WriterTo).WriteTo(w)
				n += nn
				if err != nil {
					return n, err
				}
			}
		} else {
			for _, attr := range tag {
				nn, err := attr.(io.WriterTo).WriteTo(w)
				n += nn
				if err != nil {
					return n, err
				}
			}
		}
	}

	nn, err = fmt.Fprintf(w, ">")
	n += int64(nn)
	if err != nil {
		return n, err
	}

	if children && idx >= 0 {
		for _, child := range tag[idx:] {
			nn, err := render(w, child)
			n += nn
			if err != nil {
				return n, err
			}
		}
	}

	nn, err = fmt.Fprintf(w, "</dt>")
	n += int64(nn)

	return n, nil
}
func (tag Dt) element() {}
func (tag Dt) Reader() io.Reader {
	r, w := io.Pipe()
	go func(w *io.PipeWriter) {
		_, err := tag.WriteTo(w)
		if err != nil {
			w.CloseWithError(err)
		} else {
			w.Close()
		}
	}(w)
	return r
}
func (tag Dt) String() string {
	b := strings.Builder{}
	tag.WriteTo(&b)
	return b.String()
}
func (tag Dt) Bytes() []byte {
	b := bytes.Buffer{}
	tag.WriteTo(&b)
	return b.Bytes()
}


type Em []any

func (tag Em) WriteTo(w io.Writer) (int64, error) {
	n := int64(0)

	nn, err := fmt.Fprintf(w, "<em")
	n += int64(nn)
	if err != nil {
		return n, err
	}

	children := len(tag) > 0
	idx := 0

	if children {
		slices.SortStableFunc(tag, sort)
		idx = slices.IndexFunc(tag, index)

		if idx >= 0 {
			for _, attr := range tag[:idx] {
				nn, err := attr.(io.WriterTo).WriteTo(w)
				n += nn
				if err != nil {
					return n, err
				}
			}
		} else {
			for _, attr := range tag {
				nn, err := attr.(io.WriterTo).WriteTo(w)
				n += nn
				if err != nil {
					return n, err
				}
			}
		}
	}

	nn, err = fmt.Fprintf(w, ">")
	n += int64(nn)
	if err != nil {
		return n, err
	}

	if children && idx >= 0 {
		for _, child := range tag[idx:] {
			nn, err := render(w, child)
			n += nn
			if err != nil {
				return n, err
			}
		}
	}

	nn, err = fmt.Fprintf(w, "</em>")
	n += int64(nn)

	return n, nil
}
func (tag Em) element() {}
func (tag Em) Reader() io.Reader {
	r, w := io.Pipe()
	go func(w *io.PipeWriter) {
		_, err := tag.WriteTo(w)
		if err != nil {
			w.CloseWithError(err)
		} else {
			w.Close()
		}
	}(w)
	return r
}
func (tag Em) String() string {
	b := strings.Builder{}
	tag.WriteTo(&b)
	return b.String()
}
func (tag Em) Bytes() []byte {
	b := bytes.Buffer{}
	tag.WriteTo(&b)
	return b.Bytes()
}


type Embed baseAttrs

func (tag Embed) WriteTo(w io.Writer) (int64, error) {
	n := int64(0)

	nn, err := toInt64Error(fmt.Fprintf(w, "<embed"))
	n += int64(nn)
	if err != nil {
		return n, err
	}

	nn, err = baseAttrs(tag).WriteTo(w)
	n += nn
	if err != nil {
		return n, err
	}

	nn, err = toInt64Error(fmt.Fprintf(w, "/>"))
	n += int64(nn)
	return n, err
}
func (tag Embed) element() {}
func (tag Embed) Reader() io.Reader {
	r, w := io.Pipe()
	go func(w *io.PipeWriter) {
		_, err := tag.WriteTo(w)
		if err != nil {
			w.CloseWithError(err)
		} else {
			w.Close()
		}
	}(w)
	return r
}
func (tag Embed) String() string {
	b := strings.Builder{}
	tag.WriteTo(&b)
	return b.String()
}
func (tag Embed) Bytes() []byte {
	b := bytes.Buffer{}
	tag.WriteTo(&b)
	return b.Bytes()
}


type Fieldset []any

func (tag Fieldset) WriteTo(w io.Writer) (int64, error) {
	n := int64(0)

	nn, err := fmt.Fprintf(w, "<fieldset")
	n += int64(nn)
	if err != nil {
		return n, err
	}

	children := len(tag) > 0
	idx := 0

	if children {
		slices.SortStableFunc(tag, sort)
		idx = slices.IndexFunc(tag, index)

		if idx >= 0 {
			for _, attr := range tag[:idx] {
				nn, err := attr.(io.WriterTo).WriteTo(w)
				n += nn
				if err != nil {
					return n, err
				}
			}
		} else {
			for _, attr := range tag {
				nn, err := attr.(io.WriterTo).WriteTo(w)
				n += nn
				if err != nil {
					return n, err
				}
			}
		}
	}

	nn, err = fmt.Fprintf(w, ">")
	n += int64(nn)
	if err != nil {
		return n, err
	}

	if children && idx >= 0 {
		for _, child := range tag[idx:] {
			nn, err := render(w, child)
			n += nn
			if err != nil {
				return n, err
			}
		}
	}

	nn, err = fmt.Fprintf(w, "</fieldset>")
	n += int64(nn)

	return n, nil
}
func (tag Fieldset) element() {}
func (tag Fieldset) Reader() io.Reader {
	r, w := io.Pipe()
	go func(w *io.PipeWriter) {
		_, err := tag.WriteTo(w)
		if err != nil {
			w.CloseWithError(err)
		} else {
			w.Close()
		}
	}(w)
	return r
}
func (tag Fieldset) String() string {
	b := strings.Builder{}
	tag.WriteTo(&b)
	return b.String()
}
func (tag Fieldset) Bytes() []byte {
	b := bytes.Buffer{}
	tag.WriteTo(&b)
	return b.Bytes()
}


type Figcaption []any

func (tag Figcaption) WriteTo(w io.Writer) (int64, error) {
	n := int64(0)

	nn, err := fmt.Fprintf(w, "<figcaption")
	n += int64(nn)
	if err != nil {
		return n, err
	}

	children := len(tag) > 0
	idx := 0

	if children {
		slices.SortStableFunc(tag, sort)
		idx = slices.IndexFunc(tag, index)

		if idx >= 0 {
			for _, attr := range tag[:idx] {
				nn, err := attr.(io.WriterTo).WriteTo(w)
				n += nn
				if err != nil {
					return n, err
				}
			}
		} else {
			for _, attr := range tag {
				nn, err := attr.(io.WriterTo).WriteTo(w)
				n += nn
				if err != nil {
					return n, err
				}
			}
		}
	}

	nn, err = fmt.Fprintf(w, ">")
	n += int64(nn)
	if err != nil {
		return n, err
	}

	if children && idx >= 0 {
		for _, child := range tag[idx:] {
			nn, err := render(w, child)
			n += nn
			if err != nil {
				return n, err
			}
		}
	}

	nn, err = fmt.Fprintf(w, "</figcaption>")
	n += int64(nn)

	return n, nil
}
func (tag Figcaption) element() {}
func (tag Figcaption) Reader() io.Reader {
	r, w := io.Pipe()
	go func(w *io.PipeWriter) {
		_, err := tag.WriteTo(w)
		if err != nil {
			w.CloseWithError(err)
		} else {
			w.Close()
		}
	}(w)
	return r
}
func (tag Figcaption) String() string {
	b := strings.Builder{}
	tag.WriteTo(&b)
	return b.String()
}
func (tag Figcaption) Bytes() []byte {
	b := bytes.Buffer{}
	tag.WriteTo(&b)
	return b.Bytes()
}


type Figure []any

func (tag Figure) WriteTo(w io.Writer) (int64, error) {
	n := int64(0)

	nn, err := fmt.Fprintf(w, "<figure")
	n += int64(nn)
	if err != nil {
		return n, err
	}

	children := len(tag) > 0
	idx := 0

	if children {
		slices.SortStableFunc(tag, sort)
		idx = slices.IndexFunc(tag, index)

		if idx >= 0 {
			for _, attr := range tag[:idx] {
				nn, err := attr.(io.WriterTo).WriteTo(w)
				n += nn
				if err != nil {
					return n, err
				}
			}
		} else {
			for _, attr := range tag {
				nn, err := attr.(io.WriterTo).WriteTo(w)
				n += nn
				if err != nil {
					return n, err
				}
			}
		}
	}

	nn, err = fmt.Fprintf(w, ">")
	n += int64(nn)
	if err != nil {
		return n, err
	}

	if children && idx >= 0 {
		for _, child := range tag[idx:] {
			nn, err := render(w, child)
			n += nn
			if err != nil {
				return n, err
			}
		}
	}

	nn, err = fmt.Fprintf(w, "</figure>")
	n += int64(nn)

	return n, nil
}
func (tag Figure) element() {}
func (tag Figure) Reader() io.Reader {
	r, w := io.Pipe()
	go func(w *io.PipeWriter) {
		_, err := tag.WriteTo(w)
		if err != nil {
			w.CloseWithError(err)
		} else {
			w.Close()
		}
	}(w)
	return r
}
func (tag Figure) String() string {
	b := strings.Builder{}
	tag.WriteTo(&b)
	return b.String()
}
func (tag Figure) Bytes() []byte {
	b := bytes.Buffer{}
	tag.WriteTo(&b)
	return b.Bytes()
}


type Footer []any

func (tag Footer) WriteTo(w io.Writer) (int64, error) {
	n := int64(0)

	nn, err := fmt.Fprintf(w, "<footer")
	n += int64(nn)
	if err != nil {
		return n, err
	}

	children := len(tag) > 0
	idx := 0

	if children {
		slices.SortStableFunc(tag, sort)
		idx = slices.IndexFunc(tag, index)

		if idx >= 0 {
			for _, attr := range tag[:idx] {
				nn, err := attr.(io.WriterTo).WriteTo(w)
				n += nn
				if err != nil {
					return n, err
				}
			}
		} else {
			for _, attr := range tag {
				nn, err := attr.(io.WriterTo).WriteTo(w)
				n += nn
				if err != nil {
					return n, err
				}
			}
		}
	}

	nn, err = fmt.Fprintf(w, ">")
	n += int64(nn)
	if err != nil {
		return n, err
	}

	if children && idx >= 0 {
		for _, child := range tag[idx:] {
			nn, err := render(w, child)
			n += nn
			if err != nil {
				return n, err
			}
		}
	}

	nn, err = fmt.Fprintf(w, "</footer>")
	n += int64(nn)

	return n, nil
}
func (tag Footer) element() {}
func (tag Footer) Reader() io.Reader {
	r, w := io.Pipe()
	go func(w *io.PipeWriter) {
		_, err := tag.WriteTo(w)
		if err != nil {
			w.CloseWithError(err)
		} else {
			w.Close()
		}
	}(w)
	return r
}
func (tag Footer) String() string {
	b := strings.Builder{}
	tag.WriteTo(&b)
	return b.String()
}
func (tag Footer) Bytes() []byte {
	b := bytes.Buffer{}
	tag.WriteTo(&b)
	return b.Bytes()
}


type Form []any

func (tag Form) WriteTo(w io.Writer) (int64, error) {
	n := int64(0)

	nn, err := fmt.Fprintf(w, "<form")
	n += int64(nn)
	if err != nil {
		return n, err
	}

	children := len(tag) > 0
	idx := 0

	if children {
		slices.SortStableFunc(tag, sort)
		idx = slices.IndexFunc(tag, index)

		if idx >= 0 {
			for _, attr := range tag[:idx] {
				nn, err := attr.(io.WriterTo).WriteTo(w)
				n += nn
				if err != nil {
					return n, err
				}
			}
		} else {
			for _, attr := range tag {
				nn, err := attr.(io.WriterTo).WriteTo(w)
				n += nn
				if err != nil {
					return n, err
				}
			}
		}
	}

	nn, err = fmt.Fprintf(w, ">")
	n += int64(nn)
	if err != nil {
		return n, err
	}

	if children && idx >= 0 {
		for _, child := range tag[idx:] {
			nn, err := render(w, child)
			n += nn
			if err != nil {
				return n, err
			}
		}
	}

	nn, err = fmt.Fprintf(w, "</form>")
	n += int64(nn)

	return n, nil
}
func (tag Form) element() {}
func (tag Form) Reader() io.Reader {
	r, w := io.Pipe()
	go func(w *io.PipeWriter) {
		_, err := tag.WriteTo(w)
		if err != nil {
			w.CloseWithError(err)
		} else {
			w.Close()
		}
	}(w)
	return r
}
func (tag Form) String() string {
	b := strings.Builder{}
	tag.WriteTo(&b)
	return b.String()
}
func (tag Form) Bytes() []byte {
	b := bytes.Buffer{}
	tag.WriteTo(&b)
	return b.Bytes()
}


type H1 []any

func (tag H1) WriteTo(w io.Writer) (int64, error) {
	n := int64(0)

	nn, err := fmt.Fprintf(w, "<h1")
	n += int64(nn)
	if err != nil {
		return n, err
	}

	children := len(tag) > 0
	idx := 0

	if children {
		slices.SortStableFunc(tag, sort)
		idx = slices.IndexFunc(tag, index)

		if idx >= 0 {
			for _, attr := range tag[:idx] {
				nn, err := attr.(io.WriterTo).WriteTo(w)
				n += nn
				if err != nil {
					return n, err
				}
			}
		} else {
			for _, attr := range tag {
				nn, err := attr.(io.WriterTo).WriteTo(w)
				n += nn
				if err != nil {
					return n, err
				}
			}
		}
	}

	nn, err = fmt.Fprintf(w, ">")
	n += int64(nn)
	if err != nil {
		return n, err
	}

	if children && idx >= 0 {
		for _, child := range tag[idx:] {
			nn, err := render(w, child)
			n += nn
			if err != nil {
				return n, err
			}
		}
	}

	nn, err = fmt.Fprintf(w, "</h1>")
	n += int64(nn)

	return n, nil
}
func (tag H1) element() {}
func (tag H1) Reader() io.Reader {
	r, w := io.Pipe()
	go func(w *io.PipeWriter) {
		_, err := tag.WriteTo(w)
		if err != nil {
			w.CloseWithError(err)
		} else {
			w.Close()
		}
	}(w)
	return r
}
func (tag H1) String() string {
	b := strings.Builder{}
	tag.WriteTo(&b)
	return b.String()
}
func (tag H1) Bytes() []byte {
	b := bytes.Buffer{}
	tag.WriteTo(&b)
	return b.Bytes()
}


type H2 []any

func (tag H2) WriteTo(w io.Writer) (int64, error) {
	n := int64(0)

	nn, err := fmt.Fprintf(w, "<h2")
	n += int64(nn)
	if err != nil {
		return n, err
	}

	children := len(tag) > 0
	idx := 0

	if children {
		slices.SortStableFunc(tag, sort)
		idx = slices.IndexFunc(tag, index)

		if idx >= 0 {
			for _, attr := range tag[:idx] {
				nn, err := attr.(io.WriterTo).WriteTo(w)
				n += nn
				if err != nil {
					return n, err
				}
			}
		} else {
			for _, attr := range tag {
				nn, err := attr.(io.WriterTo).WriteTo(w)
				n += nn
				if err != nil {
					return n, err
				}
			}
		}
	}

	nn, err = fmt.Fprintf(w, ">")
	n += int64(nn)
	if err != nil {
		return n, err
	}

	if children && idx >= 0 {
		for _, child := range tag[idx:] {
			nn, err := render(w, child)
			n += nn
			if err != nil {
				return n, err
			}
		}
	}

	nn, err = fmt.Fprintf(w, "</h2>")
	n += int64(nn)

	return n, nil
}
func (tag H2) element() {}
func (tag H2) Reader() io.Reader {
	r, w := io.Pipe()
	go func(w *io.PipeWriter) {
		_, err := tag.WriteTo(w)
		if err != nil {
			w.CloseWithError(err)
		} else {
			w.Close()
		}
	}(w)
	return r
}
func (tag H2) String() string {
	b := strings.Builder{}
	tag.WriteTo(&b)
	return b.String()
}
func (tag H2) Bytes() []byte {
	b := bytes.Buffer{}
	tag.WriteTo(&b)
	return b.Bytes()
}


type H3 []any

func (tag H3) WriteTo(w io.Writer) (int64, error) {
	n := int64(0)

	nn, err := fmt.Fprintf(w, "<h3")
	n += int64(nn)
	if err != nil {
		return n, err
	}

	children := len(tag) > 0
	idx := 0

	if children {
		slices.SortStableFunc(tag, sort)
		idx = slices.IndexFunc(tag, index)

		if idx >= 0 {
			for _, attr := range tag[:idx] {
				nn, err := attr.(io.WriterTo).WriteTo(w)
				n += nn
				if err != nil {
					return n, err
				}
			}
		} else {
			for _, attr := range tag {
				nn, err := attr.(io.WriterTo).WriteTo(w)
				n += nn
				if err != nil {
					return n, err
				}
			}
		}
	}

	nn, err = fmt.Fprintf(w, ">")
	n += int64(nn)
	if err != nil {
		return n, err
	}

	if children && idx >= 0 {
		for _, child := range tag[idx:] {
			nn, err := render(w, child)
			n += nn
			if err != nil {
				return n, err
			}
		}
	}

	nn, err = fmt.Fprintf(w, "</h3>")
	n += int64(nn)

	return n, nil
}
func (tag H3) element() {}
func (tag H3) Reader() io.Reader {
	r, w := io.Pipe()
	go func(w *io.PipeWriter) {
		_, err := tag.WriteTo(w)
		if err != nil {
			w.CloseWithError(err)
		} else {
			w.Close()
		}
	}(w)
	return r
}
func (tag H3) String() string {
	b := strings.Builder{}
	tag.WriteTo(&b)
	return b.String()
}
func (tag H3) Bytes() []byte {
	b := bytes.Buffer{}
	tag.WriteTo(&b)
	return b.Bytes()
}


type H4 []any

func (tag H4) WriteTo(w io.Writer) (int64, error) {
	n := int64(0)

	nn, err := fmt.Fprintf(w, "<h4")
	n += int64(nn)
	if err != nil {
		return n, err
	}

	children := len(tag) > 0
	idx := 0

	if children {
		slices.SortStableFunc(tag, sort)
		idx = slices.IndexFunc(tag, index)

		if idx >= 0 {
			for _, attr := range tag[:idx] {
				nn, err := attr.(io.WriterTo).WriteTo(w)
				n += nn
				if err != nil {
					return n, err
				}
			}
		} else {
			for _, attr := range tag {
				nn, err := attr.(io.WriterTo).WriteTo(w)
				n += nn
				if err != nil {
					return n, err
				}
			}
		}
	}

	nn, err = fmt.Fprintf(w, ">")
	n += int64(nn)
	if err != nil {
		return n, err
	}

	if children && idx >= 0 {
		for _, child := range tag[idx:] {
			nn, err := render(w, child)
			n += nn
			if err != nil {
				return n, err
			}
		}
	}

	nn, err = fmt.Fprintf(w, "</h4>")
	n += int64(nn)

	return n, nil
}
func (tag H4) element() {}
func (tag H4) Reader() io.Reader {
	r, w := io.Pipe()
	go func(w *io.PipeWriter) {
		_, err := tag.WriteTo(w)
		if err != nil {
			w.CloseWithError(err)
		} else {
			w.Close()
		}
	}(w)
	return r
}
func (tag H4) String() string {
	b := strings.Builder{}
	tag.WriteTo(&b)
	return b.String()
}
func (tag H4) Bytes() []byte {
	b := bytes.Buffer{}
	tag.WriteTo(&b)
	return b.Bytes()
}


type H5 []any

func (tag H5) WriteTo(w io.Writer) (int64, error) {
	n := int64(0)

	nn, err := fmt.Fprintf(w, "<h5")
	n += int64(nn)
	if err != nil {
		return n, err
	}

	children := len(tag) > 0
	idx := 0

	if children {
		slices.SortStableFunc(tag, sort)
		idx = slices.IndexFunc(tag, index)

		if idx >= 0 {
			for _, attr := range tag[:idx] {
				nn, err := attr.(io.WriterTo).WriteTo(w)
				n += nn
				if err != nil {
					return n, err
				}
			}
		} else {
			for _, attr := range tag {
				nn, err := attr.(io.WriterTo).WriteTo(w)
				n += nn
				if err != nil {
					return n, err
				}
			}
		}
	}

	nn, err = fmt.Fprintf(w, ">")
	n += int64(nn)
	if err != nil {
		return n, err
	}

	if children && idx >= 0 {
		for _, child := range tag[idx:] {
			nn, err := render(w, child)
			n += nn
			if err != nil {
				return n, err
			}
		}
	}

	nn, err = fmt.Fprintf(w, "</h5>")
	n += int64(nn)

	return n, nil
}
func (tag H5) element() {}
func (tag H5) Reader() io.Reader {
	r, w := io.Pipe()
	go func(w *io.PipeWriter) {
		_, err := tag.WriteTo(w)
		if err != nil {
			w.CloseWithError(err)
		} else {
			w.Close()
		}
	}(w)
	return r
}
func (tag H5) String() string {
	b := strings.Builder{}
	tag.WriteTo(&b)
	return b.String()
}
func (tag H5) Bytes() []byte {
	b := bytes.Buffer{}
	tag.WriteTo(&b)
	return b.Bytes()
}


type H6 []any

func (tag H6) WriteTo(w io.Writer) (int64, error) {
	n := int64(0)

	nn, err := fmt.Fprintf(w, "<h6")
	n += int64(nn)
	if err != nil {
		return n, err
	}

	children := len(tag) > 0
	idx := 0

	if children {
		slices.SortStableFunc(tag, sort)
		idx = slices.IndexFunc(tag, index)

		if idx >= 0 {
			for _, attr := range tag[:idx] {
				nn, err := attr.(io.WriterTo).WriteTo(w)
				n += nn
				if err != nil {
					return n, err
				}
			}
		} else {
			for _, attr := range tag {
				nn, err := attr.(io.WriterTo).WriteTo(w)
				n += nn
				if err != nil {
					return n, err
				}
			}
		}
	}

	nn, err = fmt.Fprintf(w, ">")
	n += int64(nn)
	if err != nil {
		return n, err
	}

	if children && idx >= 0 {
		for _, child := range tag[idx:] {
			nn, err := render(w, child)
			n += nn
			if err != nil {
				return n, err
			}
		}
	}

	nn, err = fmt.Fprintf(w, "</h6>")
	n += int64(nn)

	return n, nil
}
func (tag H6) element() {}
func (tag H6) Reader() io.Reader {
	r, w := io.Pipe()
	go func(w *io.PipeWriter) {
		_, err := tag.WriteTo(w)
		if err != nil {
			w.CloseWithError(err)
		} else {
			w.Close()
		}
	}(w)
	return r
}
func (tag H6) String() string {
	b := strings.Builder{}
	tag.WriteTo(&b)
	return b.String()
}
func (tag H6) Bytes() []byte {
	b := bytes.Buffer{}
	tag.WriteTo(&b)
	return b.Bytes()
}


type Head []any

func (tag Head) WriteTo(w io.Writer) (int64, error) {
	n := int64(0)

	nn, err := fmt.Fprintf(w, "<head")
	n += int64(nn)
	if err != nil {
		return n, err
	}

	children := len(tag) > 0
	idx := 0

	if children {
		slices.SortStableFunc(tag, sort)
		idx = slices.IndexFunc(tag, index)

		if idx >= 0 {
			for _, attr := range tag[:idx] {
				nn, err := attr.(io.WriterTo).WriteTo(w)
				n += nn
				if err != nil {
					return n, err
				}
			}
		} else {
			for _, attr := range tag {
				nn, err := attr.(io.WriterTo).WriteTo(w)
				n += nn
				if err != nil {
					return n, err
				}
			}
		}
	}

	nn, err = fmt.Fprintf(w, ">")
	n += int64(nn)
	if err != nil {
		return n, err
	}

	if children && idx >= 0 {
		for _, child := range tag[idx:] {
			nn, err := render(w, child)
			n += nn
			if err != nil {
				return n, err
			}
		}
	}

	nn, err = fmt.Fprintf(w, "</head>")
	n += int64(nn)

	return n, nil
}
func (tag Head) element() {}
func (tag Head) Reader() io.Reader {
	r, w := io.Pipe()
	go func(w *io.PipeWriter) {
		_, err := tag.WriteTo(w)
		if err != nil {
			w.CloseWithError(err)
		} else {
			w.Close()
		}
	}(w)
	return r
}
func (tag Head) String() string {
	b := strings.Builder{}
	tag.WriteTo(&b)
	return b.String()
}
func (tag Head) Bytes() []byte {
	b := bytes.Buffer{}
	tag.WriteTo(&b)
	return b.Bytes()
}


type Header []any

func (tag Header) WriteTo(w io.Writer) (int64, error) {
	n := int64(0)

	nn, err := fmt.Fprintf(w, "<header")
	n += int64(nn)
	if err != nil {
		return n, err
	}

	children := len(tag) > 0
	idx := 0

	if children {
		slices.SortStableFunc(tag, sort)
		idx = slices.IndexFunc(tag, index)

		if idx >= 0 {
			for _, attr := range tag[:idx] {
				nn, err := attr.(io.WriterTo).WriteTo(w)
				n += nn
				if err != nil {
					return n, err
				}
			}
		} else {
			for _, attr := range tag {
				nn, err := attr.(io.WriterTo).WriteTo(w)
				n += nn
				if err != nil {
					return n, err
				}
			}
		}
	}

	nn, err = fmt.Fprintf(w, ">")
	n += int64(nn)
	if err != nil {
		return n, err
	}

	if children && idx >= 0 {
		for _, child := range tag[idx:] {
			nn, err := render(w, child)
			n += nn
			if err != nil {
				return n, err
			}
		}
	}

	nn, err = fmt.Fprintf(w, "</header>")
	n += int64(nn)

	return n, nil
}
func (tag Header) element() {}
func (tag Header) Reader() io.Reader {
	r, w := io.Pipe()
	go func(w *io.PipeWriter) {
		_, err := tag.WriteTo(w)
		if err != nil {
			w.CloseWithError(err)
		} else {
			w.Close()
		}
	}(w)
	return r
}
func (tag Header) String() string {
	b := strings.Builder{}
	tag.WriteTo(&b)
	return b.String()
}
func (tag Header) Bytes() []byte {
	b := bytes.Buffer{}
	tag.WriteTo(&b)
	return b.Bytes()
}


type Hgroup []any

func (tag Hgroup) WriteTo(w io.Writer) (int64, error) {
	n := int64(0)

	nn, err := fmt.Fprintf(w, "<hgroup")
	n += int64(nn)
	if err != nil {
		return n, err
	}

	children := len(tag) > 0
	idx := 0

	if children {
		slices.SortStableFunc(tag, sort)
		idx = slices.IndexFunc(tag, index)

		if idx >= 0 {
			for _, attr := range tag[:idx] {
				nn, err := attr.(io.WriterTo).WriteTo(w)
				n += nn
				if err != nil {
					return n, err
				}
			}
		} else {
			for _, attr := range tag {
				nn, err := attr.(io.WriterTo).WriteTo(w)
				n += nn
				if err != nil {
					return n, err
				}
			}
		}
	}

	nn, err = fmt.Fprintf(w, ">")
	n += int64(nn)
	if err != nil {
		return n, err
	}

	if children && idx >= 0 {
		for _, child := range tag[idx:] {
			nn, err := render(w, child)
			n += nn
			if err != nil {
				return n, err
			}
		}
	}

	nn, err = fmt.Fprintf(w, "</hgroup>")
	n += int64(nn)

	return n, nil
}
func (tag Hgroup) element() {}
func (tag Hgroup) Reader() io.Reader {
	r, w := io.Pipe()
	go func(w *io.PipeWriter) {
		_, err := tag.WriteTo(w)
		if err != nil {
			w.CloseWithError(err)
		} else {
			w.Close()
		}
	}(w)
	return r
}
func (tag Hgroup) String() string {
	b := strings.Builder{}
	tag.WriteTo(&b)
	return b.String()
}
func (tag Hgroup) Bytes() []byte {
	b := bytes.Buffer{}
	tag.WriteTo(&b)
	return b.Bytes()
}


type Hr baseAttrs

func (tag Hr) WriteTo(w io.Writer) (int64, error) {
	n := int64(0)

	nn, err := toInt64Error(fmt.Fprintf(w, "<hr"))
	n += int64(nn)
	if err != nil {
		return n, err
	}

	nn, err = baseAttrs(tag).WriteTo(w)
	n += nn
	if err != nil {
		return n, err
	}

	nn, err = toInt64Error(fmt.Fprintf(w, "/>"))
	n += int64(nn)
	return n, err
}
func (tag Hr) element() {}
func (tag Hr) Reader() io.Reader {
	r, w := io.Pipe()
	go func(w *io.PipeWriter) {
		_, err := tag.WriteTo(w)
		if err != nil {
			w.CloseWithError(err)
		} else {
			w.Close()
		}
	}(w)
	return r
}
func (tag Hr) String() string {
	b := strings.Builder{}
	tag.WriteTo(&b)
	return b.String()
}
func (tag Hr) Bytes() []byte {
	b := bytes.Buffer{}
	tag.WriteTo(&b)
	return b.Bytes()
}


type Html []any

func (tag Html) WriteTo(w io.Writer) (int64, error) {
	n := int64(0)

	nn, err := fmt.Fprintf(w, "<html")
	n += int64(nn)
	if err != nil {
		return n, err
	}

	children := len(tag) > 0
	idx := 0

	if children {
		slices.SortStableFunc(tag, sort)
		idx = slices.IndexFunc(tag, index)

		if idx >= 0 {
			for _, attr := range tag[:idx] {
				nn, err := attr.(io.WriterTo).WriteTo(w)
				n += nn
				if err != nil {
					return n, err
				}
			}
		} else {
			for _, attr := range tag {
				nn, err := attr.(io.WriterTo).WriteTo(w)
				n += nn
				if err != nil {
					return n, err
				}
			}
		}
	}

	nn, err = fmt.Fprintf(w, ">")
	n += int64(nn)
	if err != nil {
		return n, err
	}

	if children && idx >= 0 {
		for _, child := range tag[idx:] {
			nn, err := render(w, child)
			n += nn
			if err != nil {
				return n, err
			}
		}
	}

	nn, err = fmt.Fprintf(w, "</html>")
	n += int64(nn)

	return n, nil
}
func (tag Html) element() {}
func (tag Html) Reader() io.Reader {
	r, w := io.Pipe()
	go func(w *io.PipeWriter) {
		_, err := tag.WriteTo(w)
		if err != nil {
			w.CloseWithError(err)
		} else {
			w.Close()
		}
	}(w)
	return r
}
func (tag Html) String() string {
	b := strings.Builder{}
	tag.WriteTo(&b)
	return b.String()
}
func (tag Html) Bytes() []byte {
	b := bytes.Buffer{}
	tag.WriteTo(&b)
	return b.Bytes()
}


type I []any

func (tag I) WriteTo(w io.Writer) (int64, error) {
	n := int64(0)

	nn, err := fmt.Fprintf(w, "<i")
	n += int64(nn)
	if err != nil {
		return n, err
	}

	children := len(tag) > 0
	idx := 0

	if children {
		slices.SortStableFunc(tag, sort)
		idx = slices.IndexFunc(tag, index)

		if idx >= 0 {
			for _, attr := range tag[:idx] {
				nn, err := attr.(io.WriterTo).WriteTo(w)
				n += nn
				if err != nil {
					return n, err
				}
			}
		} else {
			for _, attr := range tag {
				nn, err := attr.(io.WriterTo).WriteTo(w)
				n += nn
				if err != nil {
					return n, err
				}
			}
		}
	}

	nn, err = fmt.Fprintf(w, ">")
	n += int64(nn)
	if err != nil {
		return n, err
	}

	if children && idx >= 0 {
		for _, child := range tag[idx:] {
			nn, err := render(w, child)
			n += nn
			if err != nil {
				return n, err
			}
		}
	}

	nn, err = fmt.Fprintf(w, "</i>")
	n += int64(nn)

	return n, nil
}
func (tag I) element() {}
func (tag I) Reader() io.Reader {
	r, w := io.Pipe()
	go func(w *io.PipeWriter) {
		_, err := tag.WriteTo(w)
		if err != nil {
			w.CloseWithError(err)
		} else {
			w.Close()
		}
	}(w)
	return r
}
func (tag I) String() string {
	b := strings.Builder{}
	tag.WriteTo(&b)
	return b.String()
}
func (tag I) Bytes() []byte {
	b := bytes.Buffer{}
	tag.WriteTo(&b)
	return b.Bytes()
}


type Iframe []any

func (tag Iframe) WriteTo(w io.Writer) (int64, error) {
	n := int64(0)

	nn, err := fmt.Fprintf(w, "<iframe")
	n += int64(nn)
	if err != nil {
		return n, err
	}

	children := len(tag) > 0
	idx := 0

	if children {
		slices.SortStableFunc(tag, sort)
		idx = slices.IndexFunc(tag, index)

		if idx >= 0 {
			for _, attr := range tag[:idx] {
				nn, err := attr.(io.WriterTo).WriteTo(w)
				n += nn
				if err != nil {
					return n, err
				}
			}
		} else {
			for _, attr := range tag {
				nn, err := attr.(io.WriterTo).WriteTo(w)
				n += nn
				if err != nil {
					return n, err
				}
			}
		}
	}

	nn, err = fmt.Fprintf(w, ">")
	n += int64(nn)
	if err != nil {
		return n, err
	}

	if children && idx >= 0 {
		for _, child := range tag[idx:] {
			nn, err := render(w, child)
			n += nn
			if err != nil {
				return n, err
			}
		}
	}

	nn, err = fmt.Fprintf(w, "</iframe>")
	n += int64(nn)

	return n, nil
}
func (tag Iframe) element() {}
func (tag Iframe) Reader() io.Reader {
	r, w := io.Pipe()
	go func(w *io.PipeWriter) {
		_, err := tag.WriteTo(w)
		if err != nil {
			w.CloseWithError(err)
		} else {
			w.Close()
		}
	}(w)
	return r
}
func (tag Iframe) String() string {
	b := strings.Builder{}
	tag.WriteTo(&b)
	return b.String()
}
func (tag Iframe) Bytes() []byte {
	b := bytes.Buffer{}
	tag.WriteTo(&b)
	return b.Bytes()
}


type Img baseAttrs

func (tag Img) WriteTo(w io.Writer) (int64, error) {
	n := int64(0)

	nn, err := toInt64Error(fmt.Fprintf(w, "<img"))
	n += int64(nn)
	if err != nil {
		return n, err
	}

	nn, err = baseAttrs(tag).WriteTo(w)
	n += nn
	if err != nil {
		return n, err
	}

	nn, err = toInt64Error(fmt.Fprintf(w, "/>"))
	n += int64(nn)
	return n, err
}
func (tag Img) element() {}
func (tag Img) Reader() io.Reader {
	r, w := io.Pipe()
	go func(w *io.PipeWriter) {
		_, err := tag.WriteTo(w)
		if err != nil {
			w.CloseWithError(err)
		} else {
			w.Close()
		}
	}(w)
	return r
}
func (tag Img) String() string {
	b := strings.Builder{}
	tag.WriteTo(&b)
	return b.String()
}
func (tag Img) Bytes() []byte {
	b := bytes.Buffer{}
	tag.WriteTo(&b)
	return b.Bytes()
}


type Input baseAttrs

func (tag Input) WriteTo(w io.Writer) (int64, error) {
	n := int64(0)

	nn, err := toInt64Error(fmt.Fprintf(w, "<input"))
	n += int64(nn)
	if err != nil {
		return n, err
	}

	nn, err = baseAttrs(tag).WriteTo(w)
	n += nn
	if err != nil {
		return n, err
	}

	nn, err = toInt64Error(fmt.Fprintf(w, "/>"))
	n += int64(nn)
	return n, err
}
func (tag Input) element() {}
func (tag Input) Reader() io.Reader {
	r, w := io.Pipe()
	go func(w *io.PipeWriter) {
		_, err := tag.WriteTo(w)
		if err != nil {
			w.CloseWithError(err)
		} else {
			w.Close()
		}
	}(w)
	return r
}
func (tag Input) String() string {
	b := strings.Builder{}
	tag.WriteTo(&b)
	return b.String()
}
func (tag Input) Bytes() []byte {
	b := bytes.Buffer{}
	tag.WriteTo(&b)
	return b.Bytes()
}


type Ins []any

func (tag Ins) WriteTo(w io.Writer) (int64, error) {
	n := int64(0)

	nn, err := fmt.Fprintf(w, "<ins")
	n += int64(nn)
	if err != nil {
		return n, err
	}

	children := len(tag) > 0
	idx := 0

	if children {
		slices.SortStableFunc(tag, sort)
		idx = slices.IndexFunc(tag, index)

		if idx >= 0 {
			for _, attr := range tag[:idx] {
				nn, err := attr.(io.WriterTo).WriteTo(w)
				n += nn
				if err != nil {
					return n, err
				}
			}
		} else {
			for _, attr := range tag {
				nn, err := attr.(io.WriterTo).WriteTo(w)
				n += nn
				if err != nil {
					return n, err
				}
			}
		}
	}

	nn, err = fmt.Fprintf(w, ">")
	n += int64(nn)
	if err != nil {
		return n, err
	}

	if children && idx >= 0 {
		for _, child := range tag[idx:] {
			nn, err := render(w, child)
			n += nn
			if err != nil {
				return n, err
			}
		}
	}

	nn, err = fmt.Fprintf(w, "</ins>")
	n += int64(nn)

	return n, nil
}
func (tag Ins) element() {}
func (tag Ins) Reader() io.Reader {
	r, w := io.Pipe()
	go func(w *io.PipeWriter) {
		_, err := tag.WriteTo(w)
		if err != nil {
			w.CloseWithError(err)
		} else {
			w.Close()
		}
	}(w)
	return r
}
func (tag Ins) String() string {
	b := strings.Builder{}
	tag.WriteTo(&b)
	return b.String()
}
func (tag Ins) Bytes() []byte {
	b := bytes.Buffer{}
	tag.WriteTo(&b)
	return b.Bytes()
}


type Kbd []any

func (tag Kbd) WriteTo(w io.Writer) (int64, error) {
	n := int64(0)

	nn, err := fmt.Fprintf(w, "<kbd")
	n += int64(nn)
	if err != nil {
		return n, err
	}

	children := len(tag) > 0
	idx := 0

	if children {
		slices.SortStableFunc(tag, sort)
		idx = slices.IndexFunc(tag, index)

		if idx >= 0 {
			for _, attr := range tag[:idx] {
				nn, err := attr.(io.WriterTo).WriteTo(w)
				n += nn
				if err != nil {
					return n, err
				}
			}
		} else {
			for _, attr := range tag {
				nn, err := attr.(io.WriterTo).WriteTo(w)
				n += nn
				if err != nil {
					return n, err
				}
			}
		}
	}

	nn, err = fmt.Fprintf(w, ">")
	n += int64(nn)
	if err != nil {
		return n, err
	}

	if children && idx >= 0 {
		for _, child := range tag[idx:] {
			nn, err := render(w, child)
			n += nn
			if err != nil {
				return n, err
			}
		}
	}

	nn, err = fmt.Fprintf(w, "</kbd>")
	n += int64(nn)

	return n, nil
}
func (tag Kbd) element() {}
func (tag Kbd) Reader() io.Reader {
	r, w := io.Pipe()
	go func(w *io.PipeWriter) {
		_, err := tag.WriteTo(w)
		if err != nil {
			w.CloseWithError(err)
		} else {
			w.Close()
		}
	}(w)
	return r
}
func (tag Kbd) String() string {
	b := strings.Builder{}
	tag.WriteTo(&b)
	return b.String()
}
func (tag Kbd) Bytes() []byte {
	b := bytes.Buffer{}
	tag.WriteTo(&b)
	return b.Bytes()
}


type Label []any

func (tag Label) WriteTo(w io.Writer) (int64, error) {
	n := int64(0)

	nn, err := fmt.Fprintf(w, "<label")
	n += int64(nn)
	if err != nil {
		return n, err
	}

	children := len(tag) > 0
	idx := 0

	if children {
		slices.SortStableFunc(tag, sort)
		idx = slices.IndexFunc(tag, index)

		if idx >= 0 {
			for _, attr := range tag[:idx] {
				nn, err := attr.(io.WriterTo).WriteTo(w)
				n += nn
				if err != nil {
					return n, err
				}
			}
		} else {
			for _, attr := range tag {
				nn, err := attr.(io.WriterTo).WriteTo(w)
				n += nn
				if err != nil {
					return n, err
				}
			}
		}
	}

	nn, err = fmt.Fprintf(w, ">")
	n += int64(nn)
	if err != nil {
		return n, err
	}

	if children && idx >= 0 {
		for _, child := range tag[idx:] {
			nn, err := render(w, child)
			n += nn
			if err != nil {
				return n, err
			}
		}
	}

	nn, err = fmt.Fprintf(w, "</label>")
	n += int64(nn)

	return n, nil
}
func (tag Label) element() {}
func (tag Label) Reader() io.Reader {
	r, w := io.Pipe()
	go func(w *io.PipeWriter) {
		_, err := tag.WriteTo(w)
		if err != nil {
			w.CloseWithError(err)
		} else {
			w.Close()
		}
	}(w)
	return r
}
func (tag Label) String() string {
	b := strings.Builder{}
	tag.WriteTo(&b)
	return b.String()
}
func (tag Label) Bytes() []byte {
	b := bytes.Buffer{}
	tag.WriteTo(&b)
	return b.Bytes()
}


type Legend []any

func (tag Legend) WriteTo(w io.Writer) (int64, error) {
	n := int64(0)

	nn, err := fmt.Fprintf(w, "<legend")
	n += int64(nn)
	if err != nil {
		return n, err
	}

	children := len(tag) > 0
	idx := 0

	if children {
		slices.SortStableFunc(tag, sort)
		idx = slices.IndexFunc(tag, index)

		if idx >= 0 {
			for _, attr := range tag[:idx] {
				nn, err := attr.(io.WriterTo).WriteTo(w)
				n += nn
				if err != nil {
					return n, err
				}
			}
		} else {
			for _, attr := range tag {
				nn, err := attr.(io.WriterTo).WriteTo(w)
				n += nn
				if err != nil {
					return n, err
				}
			}
		}
	}

	nn, err = fmt.Fprintf(w, ">")
	n += int64(nn)
	if err != nil {
		return n, err
	}

	if children && idx >= 0 {
		for _, child := range tag[idx:] {
			nn, err := render(w, child)
			n += nn
			if err != nil {
				return n, err
			}
		}
	}

	nn, err = fmt.Fprintf(w, "</legend>")
	n += int64(nn)

	return n, nil
}
func (tag Legend) element() {}
func (tag Legend) Reader() io.Reader {
	r, w := io.Pipe()
	go func(w *io.PipeWriter) {
		_, err := tag.WriteTo(w)
		if err != nil {
			w.CloseWithError(err)
		} else {
			w.Close()
		}
	}(w)
	return r
}
func (tag Legend) String() string {
	b := strings.Builder{}
	tag.WriteTo(&b)
	return b.String()
}
func (tag Legend) Bytes() []byte {
	b := bytes.Buffer{}
	tag.WriteTo(&b)
	return b.Bytes()
}


type Li []any

func (tag Li) WriteTo(w io.Writer) (int64, error) {
	n := int64(0)

	nn, err := fmt.Fprintf(w, "<li")
	n += int64(nn)
	if err != nil {
		return n, err
	}

	children := len(tag) > 0
	idx := 0

	if children {
		slices.SortStableFunc(tag, sort)
		idx = slices.IndexFunc(tag, index)

		if idx >= 0 {
			for _, attr := range tag[:idx] {
				nn, err := attr.(io.WriterTo).WriteTo(w)
				n += nn
				if err != nil {
					return n, err
				}
			}
		} else {
			for _, attr := range tag {
				nn, err := attr.(io.WriterTo).WriteTo(w)
				n += nn
				if err != nil {
					return n, err
				}
			}
		}
	}

	nn, err = fmt.Fprintf(w, ">")
	n += int64(nn)
	if err != nil {
		return n, err
	}

	if children && idx >= 0 {
		for _, child := range tag[idx:] {
			nn, err := render(w, child)
			n += nn
			if err != nil {
				return n, err
			}
		}
	}

	nn, err = fmt.Fprintf(w, "</li>")
	n += int64(nn)

	return n, nil
}
func (tag Li) element() {}
func (tag Li) Reader() io.Reader {
	r, w := io.Pipe()
	go func(w *io.PipeWriter) {
		_, err := tag.WriteTo(w)
		if err != nil {
			w.CloseWithError(err)
		} else {
			w.Close()
		}
	}(w)
	return r
}
func (tag Li) String() string {
	b := strings.Builder{}
	tag.WriteTo(&b)
	return b.String()
}
func (tag Li) Bytes() []byte {
	b := bytes.Buffer{}
	tag.WriteTo(&b)
	return b.Bytes()
}


type Link baseAttrs

func (tag Link) WriteTo(w io.Writer) (int64, error) {
	n := int64(0)

	nn, err := toInt64Error(fmt.Fprintf(w, "<link"))
	n += int64(nn)
	if err != nil {
		return n, err
	}

	nn, err = baseAttrs(tag).WriteTo(w)
	n += nn
	if err != nil {
		return n, err
	}

	nn, err = toInt64Error(fmt.Fprintf(w, "/>"))
	n += int64(nn)
	return n, err
}
func (tag Link) element() {}
func (tag Link) Reader() io.Reader {
	r, w := io.Pipe()
	go func(w *io.PipeWriter) {
		_, err := tag.WriteTo(w)
		if err != nil {
			w.CloseWithError(err)
		} else {
			w.Close()
		}
	}(w)
	return r
}
func (tag Link) String() string {
	b := strings.Builder{}
	tag.WriteTo(&b)
	return b.String()
}
func (tag Link) Bytes() []byte {
	b := bytes.Buffer{}
	tag.WriteTo(&b)
	return b.Bytes()
}


type Main []any

func (tag Main) WriteTo(w io.Writer) (int64, error) {
	n := int64(0)

	nn, err := fmt.Fprintf(w, "<main")
	n += int64(nn)
	if err != nil {
		return n, err
	}

	children := len(tag) > 0
	idx := 0

	if children {
		slices.SortStableFunc(tag, sort)
		idx = slices.IndexFunc(tag, index)

		if idx >= 0 {
			for _, attr := range tag[:idx] {
				nn, err := attr.(io.WriterTo).WriteTo(w)
				n += nn
				if err != nil {
					return n, err
				}
			}
		} else {
			for _, attr := range tag {
				nn, err := attr.(io.WriterTo).WriteTo(w)
				n += nn
				if err != nil {
					return n, err
				}
			}
		}
	}

	nn, err = fmt.Fprintf(w, ">")
	n += int64(nn)
	if err != nil {
		return n, err
	}

	if children && idx >= 0 {
		for _, child := range tag[idx:] {
			nn, err := render(w, child)
			n += nn
			if err != nil {
				return n, err
			}
		}
	}

	nn, err = fmt.Fprintf(w, "</main>")
	n += int64(nn)

	return n, nil
}
func (tag Main) element() {}
func (tag Main) Reader() io.Reader {
	r, w := io.Pipe()
	go func(w *io.PipeWriter) {
		_, err := tag.WriteTo(w)
		if err != nil {
			w.CloseWithError(err)
		} else {
			w.Close()
		}
	}(w)
	return r
}
func (tag Main) String() string {
	b := strings.Builder{}
	tag.WriteTo(&b)
	return b.String()
}
func (tag Main) Bytes() []byte {
	b := bytes.Buffer{}
	tag.WriteTo(&b)
	return b.Bytes()
}


type Map []any

func (tag Map) WriteTo(w io.Writer) (int64, error) {
	n := int64(0)

	nn, err := fmt.Fprintf(w, "<map")
	n += int64(nn)
	if err != nil {
		return n, err
	}

	children := len(tag) > 0
	idx := 0

	if children {
		slices.SortStableFunc(tag, sort)
		idx = slices.IndexFunc(tag, index)

		if idx >= 0 {
			for _, attr := range tag[:idx] {
				nn, err := attr.(io.WriterTo).WriteTo(w)
				n += nn
				if err != nil {
					return n, err
				}
			}
		} else {
			for _, attr := range tag {
				nn, err := attr.(io.WriterTo).WriteTo(w)
				n += nn
				if err != nil {
					return n, err
				}
			}
		}
	}

	nn, err = fmt.Fprintf(w, ">")
	n += int64(nn)
	if err != nil {
		return n, err
	}

	if children && idx >= 0 {
		for _, child := range tag[idx:] {
			nn, err := render(w, child)
			n += nn
			if err != nil {
				return n, err
			}
		}
	}

	nn, err = fmt.Fprintf(w, "</map>")
	n += int64(nn)

	return n, nil
}
func (tag Map) element() {}
func (tag Map) Reader() io.Reader {
	r, w := io.Pipe()
	go func(w *io.PipeWriter) {
		_, err := tag.WriteTo(w)
		if err != nil {
			w.CloseWithError(err)
		} else {
			w.Close()
		}
	}(w)
	return r
}
func (tag Map) String() string {
	b := strings.Builder{}
	tag.WriteTo(&b)
	return b.String()
}
func (tag Map) Bytes() []byte {
	b := bytes.Buffer{}
	tag.WriteTo(&b)
	return b.Bytes()
}


type Mark []any

func (tag Mark) WriteTo(w io.Writer) (int64, error) {
	n := int64(0)

	nn, err := fmt.Fprintf(w, "<mark")
	n += int64(nn)
	if err != nil {
		return n, err
	}

	children := len(tag) > 0
	idx := 0

	if children {
		slices.SortStableFunc(tag, sort)
		idx = slices.IndexFunc(tag, index)

		if idx >= 0 {
			for _, attr := range tag[:idx] {
				nn, err := attr.(io.WriterTo).WriteTo(w)
				n += nn
				if err != nil {
					return n, err
				}
			}
		} else {
			for _, attr := range tag {
				nn, err := attr.(io.WriterTo).WriteTo(w)
				n += nn
				if err != nil {
					return n, err
				}
			}
		}
	}

	nn, err = fmt.Fprintf(w, ">")
	n += int64(nn)
	if err != nil {
		return n, err
	}

	if children && idx >= 0 {
		for _, child := range tag[idx:] {
			nn, err := render(w, child)
			n += nn
			if err != nil {
				return n, err
			}
		}
	}

	nn, err = fmt.Fprintf(w, "</mark>")
	n += int64(nn)

	return n, nil
}
func (tag Mark) element() {}
func (tag Mark) Reader() io.Reader {
	r, w := io.Pipe()
	go func(w *io.PipeWriter) {
		_, err := tag.WriteTo(w)
		if err != nil {
			w.CloseWithError(err)
		} else {
			w.Close()
		}
	}(w)
	return r
}
func (tag Mark) String() string {
	b := strings.Builder{}
	tag.WriteTo(&b)
	return b.String()
}
func (tag Mark) Bytes() []byte {
	b := bytes.Buffer{}
	tag.WriteTo(&b)
	return b.Bytes()
}


type Math []any

func (tag Math) WriteTo(w io.Writer) (int64, error) {
	n := int64(0)

	nn, err := fmt.Fprintf(w, "<math")
	n += int64(nn)
	if err != nil {
		return n, err
	}

	children := len(tag) > 0
	idx := 0

	if children {
		slices.SortStableFunc(tag, sort)
		idx = slices.IndexFunc(tag, index)

		if idx >= 0 {
			for _, attr := range tag[:idx] {
				nn, err := attr.(io.WriterTo).WriteTo(w)
				n += nn
				if err != nil {
					return n, err
				}
			}
		} else {
			for _, attr := range tag {
				nn, err := attr.(io.WriterTo).WriteTo(w)
				n += nn
				if err != nil {
					return n, err
				}
			}
		}
	}

	nn, err = fmt.Fprintf(w, ">")
	n += int64(nn)
	if err != nil {
		return n, err
	}

	if children && idx >= 0 {
		for _, child := range tag[idx:] {
			nn, err := render(w, child)
			n += nn
			if err != nil {
				return n, err
			}
		}
	}

	nn, err = fmt.Fprintf(w, "</math>")
	n += int64(nn)

	return n, nil
}
func (tag Math) element() {}
func (tag Math) Reader() io.Reader {
	r, w := io.Pipe()
	go func(w *io.PipeWriter) {
		_, err := tag.WriteTo(w)
		if err != nil {
			w.CloseWithError(err)
		} else {
			w.Close()
		}
	}(w)
	return r
}
func (tag Math) String() string {
	b := strings.Builder{}
	tag.WriteTo(&b)
	return b.String()
}
func (tag Math) Bytes() []byte {
	b := bytes.Buffer{}
	tag.WriteTo(&b)
	return b.Bytes()
}


type Menu []any

func (tag Menu) WriteTo(w io.Writer) (int64, error) {
	n := int64(0)

	nn, err := fmt.Fprintf(w, "<menu")
	n += int64(nn)
	if err != nil {
		return n, err
	}

	children := len(tag) > 0
	idx := 0

	if children {
		slices.SortStableFunc(tag, sort)
		idx = slices.IndexFunc(tag, index)

		if idx >= 0 {
			for _, attr := range tag[:idx] {
				nn, err := attr.(io.WriterTo).WriteTo(w)
				n += nn
				if err != nil {
					return n, err
				}
			}
		} else {
			for _, attr := range tag {
				nn, err := attr.(io.WriterTo).WriteTo(w)
				n += nn
				if err != nil {
					return n, err
				}
			}
		}
	}

	nn, err = fmt.Fprintf(w, ">")
	n += int64(nn)
	if err != nil {
		return n, err
	}

	if children && idx >= 0 {
		for _, child := range tag[idx:] {
			nn, err := render(w, child)
			n += nn
			if err != nil {
				return n, err
			}
		}
	}

	nn, err = fmt.Fprintf(w, "</menu>")
	n += int64(nn)

	return n, nil
}
func (tag Menu) element() {}
func (tag Menu) Reader() io.Reader {
	r, w := io.Pipe()
	go func(w *io.PipeWriter) {
		_, err := tag.WriteTo(w)
		if err != nil {
			w.CloseWithError(err)
		} else {
			w.Close()
		}
	}(w)
	return r
}
func (tag Menu) String() string {
	b := strings.Builder{}
	tag.WriteTo(&b)
	return b.String()
}
func (tag Menu) Bytes() []byte {
	b := bytes.Buffer{}
	tag.WriteTo(&b)
	return b.Bytes()
}


type Menuitem baseAttrs

func (tag Menuitem) WriteTo(w io.Writer) (int64, error) {
	n := int64(0)

	nn, err := toInt64Error(fmt.Fprintf(w, "<menuitem"))
	n += int64(nn)
	if err != nil {
		return n, err
	}

	nn, err = baseAttrs(tag).WriteTo(w)
	n += nn
	if err != nil {
		return n, err
	}

	nn, err = toInt64Error(fmt.Fprintf(w, "/>"))
	n += int64(nn)
	return n, err
}
func (tag Menuitem) element() {}
func (tag Menuitem) Reader() io.Reader {
	r, w := io.Pipe()
	go func(w *io.PipeWriter) {
		_, err := tag.WriteTo(w)
		if err != nil {
			w.CloseWithError(err)
		} else {
			w.Close()
		}
	}(w)
	return r
}
func (tag Menuitem) String() string {
	b := strings.Builder{}
	tag.WriteTo(&b)
	return b.String()
}
func (tag Menuitem) Bytes() []byte {
	b := bytes.Buffer{}
	tag.WriteTo(&b)
	return b.Bytes()
}


type Meta baseAttrs

func (tag Meta) WriteTo(w io.Writer) (int64, error) {
	n := int64(0)

	nn, err := toInt64Error(fmt.Fprintf(w, "<meta"))
	n += int64(nn)
	if err != nil {
		return n, err
	}

	nn, err = baseAttrs(tag).WriteTo(w)
	n += nn
	if err != nil {
		return n, err
	}

	nn, err = toInt64Error(fmt.Fprintf(w, "/>"))
	n += int64(nn)
	return n, err
}
func (tag Meta) element() {}
func (tag Meta) Reader() io.Reader {
	r, w := io.Pipe()
	go func(w *io.PipeWriter) {
		_, err := tag.WriteTo(w)
		if err != nil {
			w.CloseWithError(err)
		} else {
			w.Close()
		}
	}(w)
	return r
}
func (tag Meta) String() string {
	b := strings.Builder{}
	tag.WriteTo(&b)
	return b.String()
}
func (tag Meta) Bytes() []byte {
	b := bytes.Buffer{}
	tag.WriteTo(&b)
	return b.Bytes()
}


type Meter []any

func (tag Meter) WriteTo(w io.Writer) (int64, error) {
	n := int64(0)

	nn, err := fmt.Fprintf(w, "<meter")
	n += int64(nn)
	if err != nil {
		return n, err
	}

	children := len(tag) > 0
	idx := 0

	if children {
		slices.SortStableFunc(tag, sort)
		idx = slices.IndexFunc(tag, index)

		if idx >= 0 {
			for _, attr := range tag[:idx] {
				nn, err := attr.(io.WriterTo).WriteTo(w)
				n += nn
				if err != nil {
					return n, err
				}
			}
		} else {
			for _, attr := range tag {
				nn, err := attr.(io.WriterTo).WriteTo(w)
				n += nn
				if err != nil {
					return n, err
				}
			}
		}
	}

	nn, err = fmt.Fprintf(w, ">")
	n += int64(nn)
	if err != nil {
		return n, err
	}

	if children && idx >= 0 {
		for _, child := range tag[idx:] {
			nn, err := render(w, child)
			n += nn
			if err != nil {
				return n, err
			}
		}
	}

	nn, err = fmt.Fprintf(w, "</meter>")
	n += int64(nn)

	return n, nil
}
func (tag Meter) element() {}
func (tag Meter) Reader() io.Reader {
	r, w := io.Pipe()
	go func(w *io.PipeWriter) {
		_, err := tag.WriteTo(w)
		if err != nil {
			w.CloseWithError(err)
		} else {
			w.Close()
		}
	}(w)
	return r
}
func (tag Meter) String() string {
	b := strings.Builder{}
	tag.WriteTo(&b)
	return b.String()
}
func (tag Meter) Bytes() []byte {
	b := bytes.Buffer{}
	tag.WriteTo(&b)
	return b.Bytes()
}


type Nav []any

func (tag Nav) WriteTo(w io.Writer) (int64, error) {
	n := int64(0)

	nn, err := fmt.Fprintf(w, "<nav")
	n += int64(nn)
	if err != nil {
		return n, err
	}

	children := len(tag) > 0
	idx := 0

	if children {
		slices.SortStableFunc(tag, sort)
		idx = slices.IndexFunc(tag, index)

		if idx >= 0 {
			for _, attr := range tag[:idx] {
				nn, err := attr.(io.WriterTo).WriteTo(w)
				n += nn
				if err != nil {
					return n, err
				}
			}
		} else {
			for _, attr := range tag {
				nn, err := attr.(io.WriterTo).WriteTo(w)
				n += nn
				if err != nil {
					return n, err
				}
			}
		}
	}

	nn, err = fmt.Fprintf(w, ">")
	n += int64(nn)
	if err != nil {
		return n, err
	}

	if children && idx >= 0 {
		for _, child := range tag[idx:] {
			nn, err := render(w, child)
			n += nn
			if err != nil {
				return n, err
			}
		}
	}

	nn, err = fmt.Fprintf(w, "</nav>")
	n += int64(nn)

	return n, nil
}
func (tag Nav) element() {}
func (tag Nav) Reader() io.Reader {
	r, w := io.Pipe()
	go func(w *io.PipeWriter) {
		_, err := tag.WriteTo(w)
		if err != nil {
			w.CloseWithError(err)
		} else {
			w.Close()
		}
	}(w)
	return r
}
func (tag Nav) String() string {
	b := strings.Builder{}
	tag.WriteTo(&b)
	return b.String()
}
func (tag Nav) Bytes() []byte {
	b := bytes.Buffer{}
	tag.WriteTo(&b)
	return b.Bytes()
}


type Noscript []any

func (tag Noscript) WriteTo(w io.Writer) (int64, error) {
	n := int64(0)

	nn, err := fmt.Fprintf(w, "<noscript")
	n += int64(nn)
	if err != nil {
		return n, err
	}

	children := len(tag) > 0
	idx := 0

	if children {
		slices.SortStableFunc(tag, sort)
		idx = slices.IndexFunc(tag, index)

		if idx >= 0 {
			for _, attr := range tag[:idx] {
				nn, err := attr.(io.WriterTo).WriteTo(w)
				n += nn
				if err != nil {
					return n, err
				}
			}
		} else {
			for _, attr := range tag {
				nn, err := attr.(io.WriterTo).WriteTo(w)
				n += nn
				if err != nil {
					return n, err
				}
			}
		}
	}

	nn, err = fmt.Fprintf(w, ">")
	n += int64(nn)
	if err != nil {
		return n, err
	}

	if children && idx >= 0 {
		for _, child := range tag[idx:] {
			nn, err := render(w, child)
			n += nn
			if err != nil {
				return n, err
			}
		}
	}

	nn, err = fmt.Fprintf(w, "</noscript>")
	n += int64(nn)

	return n, nil
}
func (tag Noscript) element() {}
func (tag Noscript) Reader() io.Reader {
	r, w := io.Pipe()
	go func(w *io.PipeWriter) {
		_, err := tag.WriteTo(w)
		if err != nil {
			w.CloseWithError(err)
		} else {
			w.Close()
		}
	}(w)
	return r
}
func (tag Noscript) String() string {
	b := strings.Builder{}
	tag.WriteTo(&b)
	return b.String()
}
func (tag Noscript) Bytes() []byte {
	b := bytes.Buffer{}
	tag.WriteTo(&b)
	return b.Bytes()
}


type Object []any

func (tag Object) WriteTo(w io.Writer) (int64, error) {
	n := int64(0)

	nn, err := fmt.Fprintf(w, "<object")
	n += int64(nn)
	if err != nil {
		return n, err
	}

	children := len(tag) > 0
	idx := 0

	if children {
		slices.SortStableFunc(tag, sort)
		idx = slices.IndexFunc(tag, index)

		if idx >= 0 {
			for _, attr := range tag[:idx] {
				nn, err := attr.(io.WriterTo).WriteTo(w)
				n += nn
				if err != nil {
					return n, err
				}
			}
		} else {
			for _, attr := range tag {
				nn, err := attr.(io.WriterTo).WriteTo(w)
				n += nn
				if err != nil {
					return n, err
				}
			}
		}
	}

	nn, err = fmt.Fprintf(w, ">")
	n += int64(nn)
	if err != nil {
		return n, err
	}

	if children && idx >= 0 {
		for _, child := range tag[idx:] {
			nn, err := render(w, child)
			n += nn
			if err != nil {
				return n, err
			}
		}
	}

	nn, err = fmt.Fprintf(w, "</object>")
	n += int64(nn)

	return n, nil
}
func (tag Object) element() {}
func (tag Object) Reader() io.Reader {
	r, w := io.Pipe()
	go func(w *io.PipeWriter) {
		_, err := tag.WriteTo(w)
		if err != nil {
			w.CloseWithError(err)
		} else {
			w.Close()
		}
	}(w)
	return r
}
func (tag Object) String() string {
	b := strings.Builder{}
	tag.WriteTo(&b)
	return b.String()
}
func (tag Object) Bytes() []byte {
	b := bytes.Buffer{}
	tag.WriteTo(&b)
	return b.Bytes()
}


type Ol []any

func (tag Ol) WriteTo(w io.Writer) (int64, error) {
	n := int64(0)

	nn, err := fmt.Fprintf(w, "<ol")
	n += int64(nn)
	if err != nil {
		return n, err
	}

	children := len(tag) > 0
	idx := 0

	if children {
		slices.SortStableFunc(tag, sort)
		idx = slices.IndexFunc(tag, index)

		if idx >= 0 {
			for _, attr := range tag[:idx] {
				nn, err := attr.(io.WriterTo).WriteTo(w)
				n += nn
				if err != nil {
					return n, err
				}
			}
		} else {
			for _, attr := range tag {
				nn, err := attr.(io.WriterTo).WriteTo(w)
				n += nn
				if err != nil {
					return n, err
				}
			}
		}
	}

	nn, err = fmt.Fprintf(w, ">")
	n += int64(nn)
	if err != nil {
		return n, err
	}

	if children && idx >= 0 {
		for _, child := range tag[idx:] {
			nn, err := render(w, child)
			n += nn
			if err != nil {
				return n, err
			}
		}
	}

	nn, err = fmt.Fprintf(w, "</ol>")
	n += int64(nn)

	return n, nil
}
func (tag Ol) element() {}
func (tag Ol) Reader() io.Reader {
	r, w := io.Pipe()
	go func(w *io.PipeWriter) {
		_, err := tag.WriteTo(w)
		if err != nil {
			w.CloseWithError(err)
		} else {
			w.Close()
		}
	}(w)
	return r
}
func (tag Ol) String() string {
	b := strings.Builder{}
	tag.WriteTo(&b)
	return b.String()
}
func (tag Ol) Bytes() []byte {
	b := bytes.Buffer{}
	tag.WriteTo(&b)
	return b.Bytes()
}


type Optgroup []any

func (tag Optgroup) WriteTo(w io.Writer) (int64, error) {
	n := int64(0)

	nn, err := fmt.Fprintf(w, "<optgroup")
	n += int64(nn)
	if err != nil {
		return n, err
	}

	children := len(tag) > 0
	idx := 0

	if children {
		slices.SortStableFunc(tag, sort)
		idx = slices.IndexFunc(tag, index)

		if idx >= 0 {
			for _, attr := range tag[:idx] {
				nn, err := attr.(io.WriterTo).WriteTo(w)
				n += nn
				if err != nil {
					return n, err
				}
			}
		} else {
			for _, attr := range tag {
				nn, err := attr.(io.WriterTo).WriteTo(w)
				n += nn
				if err != nil {
					return n, err
				}
			}
		}
	}

	nn, err = fmt.Fprintf(w, ">")
	n += int64(nn)
	if err != nil {
		return n, err
	}

	if children && idx >= 0 {
		for _, child := range tag[idx:] {
			nn, err := render(w, child)
			n += nn
			if err != nil {
				return n, err
			}
		}
	}

	nn, err = fmt.Fprintf(w, "</optgroup>")
	n += int64(nn)

	return n, nil
}
func (tag Optgroup) element() {}
func (tag Optgroup) Reader() io.Reader {
	r, w := io.Pipe()
	go func(w *io.PipeWriter) {
		_, err := tag.WriteTo(w)
		if err != nil {
			w.CloseWithError(err)
		} else {
			w.Close()
		}
	}(w)
	return r
}
func (tag Optgroup) String() string {
	b := strings.Builder{}
	tag.WriteTo(&b)
	return b.String()
}
func (tag Optgroup) Bytes() []byte {
	b := bytes.Buffer{}
	tag.WriteTo(&b)
	return b.Bytes()
}


type Option []any

func (tag Option) WriteTo(w io.Writer) (int64, error) {
	n := int64(0)

	nn, err := fmt.Fprintf(w, "<option")
	n += int64(nn)
	if err != nil {
		return n, err
	}

	children := len(tag) > 0
	idx := 0

	if children {
		slices.SortStableFunc(tag, sort)
		idx = slices.IndexFunc(tag, index)

		if idx >= 0 {
			for _, attr := range tag[:idx] {
				nn, err := attr.(io.WriterTo).WriteTo(w)
				n += nn
				if err != nil {
					return n, err
				}
			}
		} else {
			for _, attr := range tag {
				nn, err := attr.(io.WriterTo).WriteTo(w)
				n += nn
				if err != nil {
					return n, err
				}
			}
		}
	}

	nn, err = fmt.Fprintf(w, ">")
	n += int64(nn)
	if err != nil {
		return n, err
	}

	if children && idx >= 0 {
		for _, child := range tag[idx:] {
			nn, err := render(w, child)
			n += nn
			if err != nil {
				return n, err
			}
		}
	}

	nn, err = fmt.Fprintf(w, "</option>")
	n += int64(nn)

	return n, nil
}
func (tag Option) element() {}
func (tag Option) Reader() io.Reader {
	r, w := io.Pipe()
	go func(w *io.PipeWriter) {
		_, err := tag.WriteTo(w)
		if err != nil {
			w.CloseWithError(err)
		} else {
			w.Close()
		}
	}(w)
	return r
}
func (tag Option) String() string {
	b := strings.Builder{}
	tag.WriteTo(&b)
	return b.String()
}
func (tag Option) Bytes() []byte {
	b := bytes.Buffer{}
	tag.WriteTo(&b)
	return b.Bytes()
}


type Output []any

func (tag Output) WriteTo(w io.Writer) (int64, error) {
	n := int64(0)

	nn, err := fmt.Fprintf(w, "<output")
	n += int64(nn)
	if err != nil {
		return n, err
	}

	children := len(tag) > 0
	idx := 0

	if children {
		slices.SortStableFunc(tag, sort)
		idx = slices.IndexFunc(tag, index)

		if idx >= 0 {
			for _, attr := range tag[:idx] {
				nn, err := attr.(io.WriterTo).WriteTo(w)
				n += nn
				if err != nil {
					return n, err
				}
			}
		} else {
			for _, attr := range tag {
				nn, err := attr.(io.WriterTo).WriteTo(w)
				n += nn
				if err != nil {
					return n, err
				}
			}
		}
	}

	nn, err = fmt.Fprintf(w, ">")
	n += int64(nn)
	if err != nil {
		return n, err
	}

	if children && idx >= 0 {
		for _, child := range tag[idx:] {
			nn, err := render(w, child)
			n += nn
			if err != nil {
				return n, err
			}
		}
	}

	nn, err = fmt.Fprintf(w, "</output>")
	n += int64(nn)

	return n, nil
}
func (tag Output) element() {}
func (tag Output) Reader() io.Reader {
	r, w := io.Pipe()
	go func(w *io.PipeWriter) {
		_, err := tag.WriteTo(w)
		if err != nil {
			w.CloseWithError(err)
		} else {
			w.Close()
		}
	}(w)
	return r
}
func (tag Output) String() string {
	b := strings.Builder{}
	tag.WriteTo(&b)
	return b.String()
}
func (tag Output) Bytes() []byte {
	b := bytes.Buffer{}
	tag.WriteTo(&b)
	return b.Bytes()
}


type P []any

func (tag P) WriteTo(w io.Writer) (int64, error) {
	n := int64(0)

	nn, err := fmt.Fprintf(w, "<p")
	n += int64(nn)
	if err != nil {
		return n, err
	}

	children := len(tag) > 0
	idx := 0

	if children {
		slices.SortStableFunc(tag, sort)
		idx = slices.IndexFunc(tag, index)

		if idx >= 0 {
			for _, attr := range tag[:idx] {
				nn, err := attr.(io.WriterTo).WriteTo(w)
				n += nn
				if err != nil {
					return n, err
				}
			}
		} else {
			for _, attr := range tag {
				nn, err := attr.(io.WriterTo).WriteTo(w)
				n += nn
				if err != nil {
					return n, err
				}
			}
		}
	}

	nn, err = fmt.Fprintf(w, ">")
	n += int64(nn)
	if err != nil {
		return n, err
	}

	if children && idx >= 0 {
		for _, child := range tag[idx:] {
			nn, err := render(w, child)
			n += nn
			if err != nil {
				return n, err
			}
		}
	}

	nn, err = fmt.Fprintf(w, "</p>")
	n += int64(nn)

	return n, nil
}
func (tag P) element() {}
func (tag P) Reader() io.Reader {
	r, w := io.Pipe()
	go func(w *io.PipeWriter) {
		_, err := tag.WriteTo(w)
		if err != nil {
			w.CloseWithError(err)
		} else {
			w.Close()
		}
	}(w)
	return r
}
func (tag P) String() string {
	b := strings.Builder{}
	tag.WriteTo(&b)
	return b.String()
}
func (tag P) Bytes() []byte {
	b := bytes.Buffer{}
	tag.WriteTo(&b)
	return b.Bytes()
}


type Param baseAttrs

func (tag Param) WriteTo(w io.Writer) (int64, error) {
	n := int64(0)

	nn, err := toInt64Error(fmt.Fprintf(w, "<param"))
	n += int64(nn)
	if err != nil {
		return n, err
	}

	nn, err = baseAttrs(tag).WriteTo(w)
	n += nn
	if err != nil {
		return n, err
	}

	nn, err = toInt64Error(fmt.Fprintf(w, "/>"))
	n += int64(nn)
	return n, err
}
func (tag Param) element() {}
func (tag Param) Reader() io.Reader {
	r, w := io.Pipe()
	go func(w *io.PipeWriter) {
		_, err := tag.WriteTo(w)
		if err != nil {
			w.CloseWithError(err)
		} else {
			w.Close()
		}
	}(w)
	return r
}
func (tag Param) String() string {
	b := strings.Builder{}
	tag.WriteTo(&b)
	return b.String()
}
func (tag Param) Bytes() []byte {
	b := bytes.Buffer{}
	tag.WriteTo(&b)
	return b.Bytes()
}


type Picture []any

func (tag Picture) WriteTo(w io.Writer) (int64, error) {
	n := int64(0)

	nn, err := fmt.Fprintf(w, "<picture")
	n += int64(nn)
	if err != nil {
		return n, err
	}

	children := len(tag) > 0
	idx := 0

	if children {
		slices.SortStableFunc(tag, sort)
		idx = slices.IndexFunc(tag, index)

		if idx >= 0 {
			for _, attr := range tag[:idx] {
				nn, err := attr.(io.WriterTo).WriteTo(w)
				n += nn
				if err != nil {
					return n, err
				}
			}
		} else {
			for _, attr := range tag {
				nn, err := attr.(io.WriterTo).WriteTo(w)
				n += nn
				if err != nil {
					return n, err
				}
			}
		}
	}

	nn, err = fmt.Fprintf(w, ">")
	n += int64(nn)
	if err != nil {
		return n, err
	}

	if children && idx >= 0 {
		for _, child := range tag[idx:] {
			nn, err := render(w, child)
			n += nn
			if err != nil {
				return n, err
			}
		}
	}

	nn, err = fmt.Fprintf(w, "</picture>")
	n += int64(nn)

	return n, nil
}
func (tag Picture) element() {}
func (tag Picture) Reader() io.Reader {
	r, w := io.Pipe()
	go func(w *io.PipeWriter) {
		_, err := tag.WriteTo(w)
		if err != nil {
			w.CloseWithError(err)
		} else {
			w.Close()
		}
	}(w)
	return r
}
func (tag Picture) String() string {
	b := strings.Builder{}
	tag.WriteTo(&b)
	return b.String()
}
func (tag Picture) Bytes() []byte {
	b := bytes.Buffer{}
	tag.WriteTo(&b)
	return b.Bytes()
}


type Pre []any

func (tag Pre) WriteTo(w io.Writer) (int64, error) {
	n := int64(0)

	nn, err := fmt.Fprintf(w, "<pre")
	n += int64(nn)
	if err != nil {
		return n, err
	}

	children := len(tag) > 0
	idx := 0

	if children {
		slices.SortStableFunc(tag, sort)
		idx = slices.IndexFunc(tag, index)

		if idx >= 0 {
			for _, attr := range tag[:idx] {
				nn, err := attr.(io.WriterTo).WriteTo(w)
				n += nn
				if err != nil {
					return n, err
				}
			}
		} else {
			for _, attr := range tag {
				nn, err := attr.(io.WriterTo).WriteTo(w)
				n += nn
				if err != nil {
					return n, err
				}
			}
		}
	}

	nn, err = fmt.Fprintf(w, ">")
	n += int64(nn)
	if err != nil {
		return n, err
	}

	if children && idx >= 0 {
		for _, child := range tag[idx:] {
			nn, err := render(w, child)
			n += nn
			if err != nil {
				return n, err
			}
		}
	}

	nn, err = fmt.Fprintf(w, "</pre>")
	n += int64(nn)

	return n, nil
}
func (tag Pre) element() {}
func (tag Pre) Reader() io.Reader {
	r, w := io.Pipe()
	go func(w *io.PipeWriter) {
		_, err := tag.WriteTo(w)
		if err != nil {
			w.CloseWithError(err)
		} else {
			w.Close()
		}
	}(w)
	return r
}
func (tag Pre) String() string {
	b := strings.Builder{}
	tag.WriteTo(&b)
	return b.String()
}
func (tag Pre) Bytes() []byte {
	b := bytes.Buffer{}
	tag.WriteTo(&b)
	return b.Bytes()
}


type Progress []any

func (tag Progress) WriteTo(w io.Writer) (int64, error) {
	n := int64(0)

	nn, err := fmt.Fprintf(w, "<progress")
	n += int64(nn)
	if err != nil {
		return n, err
	}

	children := len(tag) > 0
	idx := 0

	if children {
		slices.SortStableFunc(tag, sort)
		idx = slices.IndexFunc(tag, index)

		if idx >= 0 {
			for _, attr := range tag[:idx] {
				nn, err := attr.(io.WriterTo).WriteTo(w)
				n += nn
				if err != nil {
					return n, err
				}
			}
		} else {
			for _, attr := range tag {
				nn, err := attr.(io.WriterTo).WriteTo(w)
				n += nn
				if err != nil {
					return n, err
				}
			}
		}
	}

	nn, err = fmt.Fprintf(w, ">")
	n += int64(nn)
	if err != nil {
		return n, err
	}

	if children && idx >= 0 {
		for _, child := range tag[idx:] {
			nn, err := render(w, child)
			n += nn
			if err != nil {
				return n, err
			}
		}
	}

	nn, err = fmt.Fprintf(w, "</progress>")
	n += int64(nn)

	return n, nil
}
func (tag Progress) element() {}
func (tag Progress) Reader() io.Reader {
	r, w := io.Pipe()
	go func(w *io.PipeWriter) {
		_, err := tag.WriteTo(w)
		if err != nil {
			w.CloseWithError(err)
		} else {
			w.Close()
		}
	}(w)
	return r
}
func (tag Progress) String() string {
	b := strings.Builder{}
	tag.WriteTo(&b)
	return b.String()
}
func (tag Progress) Bytes() []byte {
	b := bytes.Buffer{}
	tag.WriteTo(&b)
	return b.Bytes()
}


type Q []any

func (tag Q) WriteTo(w io.Writer) (int64, error) {
	n := int64(0)

	nn, err := fmt.Fprintf(w, "<q")
	n += int64(nn)
	if err != nil {
		return n, err
	}

	children := len(tag) > 0
	idx := 0

	if children {
		slices.SortStableFunc(tag, sort)
		idx = slices.IndexFunc(tag, index)

		if idx >= 0 {
			for _, attr := range tag[:idx] {
				nn, err := attr.(io.WriterTo).WriteTo(w)
				n += nn
				if err != nil {
					return n, err
				}
			}
		} else {
			for _, attr := range tag {
				nn, err := attr.(io.WriterTo).WriteTo(w)
				n += nn
				if err != nil {
					return n, err
				}
			}
		}
	}

	nn, err = fmt.Fprintf(w, ">")
	n += int64(nn)
	if err != nil {
		return n, err
	}

	if children && idx >= 0 {
		for _, child := range tag[idx:] {
			nn, err := render(w, child)
			n += nn
			if err != nil {
				return n, err
			}
		}
	}

	nn, err = fmt.Fprintf(w, "</q>")
	n += int64(nn)

	return n, nil
}
func (tag Q) element() {}
func (tag Q) Reader() io.Reader {
	r, w := io.Pipe()
	go func(w *io.PipeWriter) {
		_, err := tag.WriteTo(w)
		if err != nil {
			w.CloseWithError(err)
		} else {
			w.Close()
		}
	}(w)
	return r
}
func (tag Q) String() string {
	b := strings.Builder{}
	tag.WriteTo(&b)
	return b.String()
}
func (tag Q) Bytes() []byte {
	b := bytes.Buffer{}
	tag.WriteTo(&b)
	return b.Bytes()
}


type Rb []any

func (tag Rb) WriteTo(w io.Writer) (int64, error) {
	n := int64(0)

	nn, err := fmt.Fprintf(w, "<rb")
	n += int64(nn)
	if err != nil {
		return n, err
	}

	children := len(tag) > 0
	idx := 0

	if children {
		slices.SortStableFunc(tag, sort)
		idx = slices.IndexFunc(tag, index)

		if idx >= 0 {
			for _, attr := range tag[:idx] {
				nn, err := attr.(io.WriterTo).WriteTo(w)
				n += nn
				if err != nil {
					return n, err
				}
			}
		} else {
			for _, attr := range tag {
				nn, err := attr.(io.WriterTo).WriteTo(w)
				n += nn
				if err != nil {
					return n, err
				}
			}
		}
	}

	nn, err = fmt.Fprintf(w, ">")
	n += int64(nn)
	if err != nil {
		return n, err
	}

	if children && idx >= 0 {
		for _, child := range tag[idx:] {
			nn, err := render(w, child)
			n += nn
			if err != nil {
				return n, err
			}
		}
	}

	nn, err = fmt.Fprintf(w, "</rb>")
	n += int64(nn)

	return n, nil
}
func (tag Rb) element() {}
func (tag Rb) Reader() io.Reader {
	r, w := io.Pipe()
	go func(w *io.PipeWriter) {
		_, err := tag.WriteTo(w)
		if err != nil {
			w.CloseWithError(err)
		} else {
			w.Close()
		}
	}(w)
	return r
}
func (tag Rb) String() string {
	b := strings.Builder{}
	tag.WriteTo(&b)
	return b.String()
}
func (tag Rb) Bytes() []byte {
	b := bytes.Buffer{}
	tag.WriteTo(&b)
	return b.Bytes()
}


type Rp []any

func (tag Rp) WriteTo(w io.Writer) (int64, error) {
	n := int64(0)

	nn, err := fmt.Fprintf(w, "<rp")
	n += int64(nn)
	if err != nil {
		return n, err
	}

	children := len(tag) > 0
	idx := 0

	if children {
		slices.SortStableFunc(tag, sort)
		idx = slices.IndexFunc(tag, index)

		if idx >= 0 {
			for _, attr := range tag[:idx] {
				nn, err := attr.(io.WriterTo).WriteTo(w)
				n += nn
				if err != nil {
					return n, err
				}
			}
		} else {
			for _, attr := range tag {
				nn, err := attr.(io.WriterTo).WriteTo(w)
				n += nn
				if err != nil {
					return n, err
				}
			}
		}
	}

	nn, err = fmt.Fprintf(w, ">")
	n += int64(nn)
	if err != nil {
		return n, err
	}

	if children && idx >= 0 {
		for _, child := range tag[idx:] {
			nn, err := render(w, child)
			n += nn
			if err != nil {
				return n, err
			}
		}
	}

	nn, err = fmt.Fprintf(w, "</rp>")
	n += int64(nn)

	return n, nil
}
func (tag Rp) element() {}
func (tag Rp) Reader() io.Reader {
	r, w := io.Pipe()
	go func(w *io.PipeWriter) {
		_, err := tag.WriteTo(w)
		if err != nil {
			w.CloseWithError(err)
		} else {
			w.Close()
		}
	}(w)
	return r
}
func (tag Rp) String() string {
	b := strings.Builder{}
	tag.WriteTo(&b)
	return b.String()
}
func (tag Rp) Bytes() []byte {
	b := bytes.Buffer{}
	tag.WriteTo(&b)
	return b.Bytes()
}


type Rt []any

func (tag Rt) WriteTo(w io.Writer) (int64, error) {
	n := int64(0)

	nn, err := fmt.Fprintf(w, "<rt")
	n += int64(nn)
	if err != nil {
		return n, err
	}

	children := len(tag) > 0
	idx := 0

	if children {
		slices.SortStableFunc(tag, sort)
		idx = slices.IndexFunc(tag, index)

		if idx >= 0 {
			for _, attr := range tag[:idx] {
				nn, err := attr.(io.WriterTo).WriteTo(w)
				n += nn
				if err != nil {
					return n, err
				}
			}
		} else {
			for _, attr := range tag {
				nn, err := attr.(io.WriterTo).WriteTo(w)
				n += nn
				if err != nil {
					return n, err
				}
			}
		}
	}

	nn, err = fmt.Fprintf(w, ">")
	n += int64(nn)
	if err != nil {
		return n, err
	}

	if children && idx >= 0 {
		for _, child := range tag[idx:] {
			nn, err := render(w, child)
			n += nn
			if err != nil {
				return n, err
			}
		}
	}

	nn, err = fmt.Fprintf(w, "</rt>")
	n += int64(nn)

	return n, nil
}
func (tag Rt) element() {}
func (tag Rt) Reader() io.Reader {
	r, w := io.Pipe()
	go func(w *io.PipeWriter) {
		_, err := tag.WriteTo(w)
		if err != nil {
			w.CloseWithError(err)
		} else {
			w.Close()
		}
	}(w)
	return r
}
func (tag Rt) String() string {
	b := strings.Builder{}
	tag.WriteTo(&b)
	return b.String()
}
func (tag Rt) Bytes() []byte {
	b := bytes.Buffer{}
	tag.WriteTo(&b)
	return b.Bytes()
}


type Rtc []any

func (tag Rtc) WriteTo(w io.Writer) (int64, error) {
	n := int64(0)

	nn, err := fmt.Fprintf(w, "<rtc")
	n += int64(nn)
	if err != nil {
		return n, err
	}

	children := len(tag) > 0
	idx := 0

	if children {
		slices.SortStableFunc(tag, sort)
		idx = slices.IndexFunc(tag, index)

		if idx >= 0 {
			for _, attr := range tag[:idx] {
				nn, err := attr.(io.WriterTo).WriteTo(w)
				n += nn
				if err != nil {
					return n, err
				}
			}
		} else {
			for _, attr := range tag {
				nn, err := attr.(io.WriterTo).WriteTo(w)
				n += nn
				if err != nil {
					return n, err
				}
			}
		}
	}

	nn, err = fmt.Fprintf(w, ">")
	n += int64(nn)
	if err != nil {
		return n, err
	}

	if children && idx >= 0 {
		for _, child := range tag[idx:] {
			nn, err := render(w, child)
			n += nn
			if err != nil {
				return n, err
			}
		}
	}

	nn, err = fmt.Fprintf(w, "</rtc>")
	n += int64(nn)

	return n, nil
}
func (tag Rtc) element() {}
func (tag Rtc) Reader() io.Reader {
	r, w := io.Pipe()
	go func(w *io.PipeWriter) {
		_, err := tag.WriteTo(w)
		if err != nil {
			w.CloseWithError(err)
		} else {
			w.Close()
		}
	}(w)
	return r
}
func (tag Rtc) String() string {
	b := strings.Builder{}
	tag.WriteTo(&b)
	return b.String()
}
func (tag Rtc) Bytes() []byte {
	b := bytes.Buffer{}
	tag.WriteTo(&b)
	return b.Bytes()
}


type Ruby []any

func (tag Ruby) WriteTo(w io.Writer) (int64, error) {
	n := int64(0)

	nn, err := fmt.Fprintf(w, "<ruby")
	n += int64(nn)
	if err != nil {
		return n, err
	}

	children := len(tag) > 0
	idx := 0

	if children {
		slices.SortStableFunc(tag, sort)
		idx = slices.IndexFunc(tag, index)

		if idx >= 0 {
			for _, attr := range tag[:idx] {
				nn, err := attr.(io.WriterTo).WriteTo(w)
				n += nn
				if err != nil {
					return n, err
				}
			}
		} else {
			for _, attr := range tag {
				nn, err := attr.(io.WriterTo).WriteTo(w)
				n += nn
				if err != nil {
					return n, err
				}
			}
		}
	}

	nn, err = fmt.Fprintf(w, ">")
	n += int64(nn)
	if err != nil {
		return n, err
	}

	if children && idx >= 0 {
		for _, child := range tag[idx:] {
			nn, err := render(w, child)
			n += nn
			if err != nil {
				return n, err
			}
		}
	}

	nn, err = fmt.Fprintf(w, "</ruby>")
	n += int64(nn)

	return n, nil
}
func (tag Ruby) element() {}
func (tag Ruby) Reader() io.Reader {
	r, w := io.Pipe()
	go func(w *io.PipeWriter) {
		_, err := tag.WriteTo(w)
		if err != nil {
			w.CloseWithError(err)
		} else {
			w.Close()
		}
	}(w)
	return r
}
func (tag Ruby) String() string {
	b := strings.Builder{}
	tag.WriteTo(&b)
	return b.String()
}
func (tag Ruby) Bytes() []byte {
	b := bytes.Buffer{}
	tag.WriteTo(&b)
	return b.Bytes()
}


type S []any

func (tag S) WriteTo(w io.Writer) (int64, error) {
	n := int64(0)

	nn, err := fmt.Fprintf(w, "<s")
	n += int64(nn)
	if err != nil {
		return n, err
	}

	children := len(tag) > 0
	idx := 0

	if children {
		slices.SortStableFunc(tag, sort)
		idx = slices.IndexFunc(tag, index)

		if idx >= 0 {
			for _, attr := range tag[:idx] {
				nn, err := attr.(io.WriterTo).WriteTo(w)
				n += nn
				if err != nil {
					return n, err
				}
			}
		} else {
			for _, attr := range tag {
				nn, err := attr.(io.WriterTo).WriteTo(w)
				n += nn
				if err != nil {
					return n, err
				}
			}
		}
	}

	nn, err = fmt.Fprintf(w, ">")
	n += int64(nn)
	if err != nil {
		return n, err
	}

	if children && idx >= 0 {
		for _, child := range tag[idx:] {
			nn, err := render(w, child)
			n += nn
			if err != nil {
				return n, err
			}
		}
	}

	nn, err = fmt.Fprintf(w, "</s>")
	n += int64(nn)

	return n, nil
}
func (tag S) element() {}
func (tag S) Reader() io.Reader {
	r, w := io.Pipe()
	go func(w *io.PipeWriter) {
		_, err := tag.WriteTo(w)
		if err != nil {
			w.CloseWithError(err)
		} else {
			w.Close()
		}
	}(w)
	return r
}
func (tag S) String() string {
	b := strings.Builder{}
	tag.WriteTo(&b)
	return b.String()
}
func (tag S) Bytes() []byte {
	b := bytes.Buffer{}
	tag.WriteTo(&b)
	return b.Bytes()
}


type Samp []any

func (tag Samp) WriteTo(w io.Writer) (int64, error) {
	n := int64(0)

	nn, err := fmt.Fprintf(w, "<samp")
	n += int64(nn)
	if err != nil {
		return n, err
	}

	children := len(tag) > 0
	idx := 0

	if children {
		slices.SortStableFunc(tag, sort)
		idx = slices.IndexFunc(tag, index)

		if idx >= 0 {
			for _, attr := range tag[:idx] {
				nn, err := attr.(io.WriterTo).WriteTo(w)
				n += nn
				if err != nil {
					return n, err
				}
			}
		} else {
			for _, attr := range tag {
				nn, err := attr.(io.WriterTo).WriteTo(w)
				n += nn
				if err != nil {
					return n, err
				}
			}
		}
	}

	nn, err = fmt.Fprintf(w, ">")
	n += int64(nn)
	if err != nil {
		return n, err
	}

	if children && idx >= 0 {
		for _, child := range tag[idx:] {
			nn, err := render(w, child)
			n += nn
			if err != nil {
				return n, err
			}
		}
	}

	nn, err = fmt.Fprintf(w, "</samp>")
	n += int64(nn)

	return n, nil
}
func (tag Samp) element() {}
func (tag Samp) Reader() io.Reader {
	r, w := io.Pipe()
	go func(w *io.PipeWriter) {
		_, err := tag.WriteTo(w)
		if err != nil {
			w.CloseWithError(err)
		} else {
			w.Close()
		}
	}(w)
	return r
}
func (tag Samp) String() string {
	b := strings.Builder{}
	tag.WriteTo(&b)
	return b.String()
}
func (tag Samp) Bytes() []byte {
	b := bytes.Buffer{}
	tag.WriteTo(&b)
	return b.Bytes()
}


type Script []any

func (tag Script) WriteTo(w io.Writer) (int64, error) {
	n := int64(0)

	nn, err := fmt.Fprintf(w, "<script")
	n += int64(nn)
	if err != nil {
		return n, err
	}

	children := len(tag) > 0
	idx := 0

	if children {
		slices.SortStableFunc(tag, sort)
		idx = slices.IndexFunc(tag, index)

		if idx >= 0 {
			for _, attr := range tag[:idx] {
				nn, err := attr.(io.WriterTo).WriteTo(w)
				n += nn
				if err != nil {
					return n, err
				}
			}
		} else {
			for _, attr := range tag {
				nn, err := attr.(io.WriterTo).WriteTo(w)
				n += nn
				if err != nil {
					return n, err
				}
			}
		}
	}

	nn, err = fmt.Fprintf(w, ">")
	n += int64(nn)
	if err != nil {
		return n, err
	}

	if children && idx >= 0 {
		for _, child := range tag[idx:] {
			nn, err := render(w, child)
			n += nn
			if err != nil {
				return n, err
			}
		}
	}

	nn, err = fmt.Fprintf(w, "</script>")
	n += int64(nn)

	return n, nil
}
func (tag Script) element() {}
func (tag Script) Reader() io.Reader {
	r, w := io.Pipe()
	go func(w *io.PipeWriter) {
		_, err := tag.WriteTo(w)
		if err != nil {
			w.CloseWithError(err)
		} else {
			w.Close()
		}
	}(w)
	return r
}
func (tag Script) String() string {
	b := strings.Builder{}
	tag.WriteTo(&b)
	return b.String()
}
func (tag Script) Bytes() []byte {
	b := bytes.Buffer{}
	tag.WriteTo(&b)
	return b.Bytes()
}


type Search []any

func (tag Search) WriteTo(w io.Writer) (int64, error) {
	n := int64(0)

	nn, err := fmt.Fprintf(w, "<search")
	n += int64(nn)
	if err != nil {
		return n, err
	}

	children := len(tag) > 0
	idx := 0

	if children {
		slices.SortStableFunc(tag, sort)
		idx = slices.IndexFunc(tag, index)

		if idx >= 0 {
			for _, attr := range tag[:idx] {
				nn, err := attr.(io.WriterTo).WriteTo(w)
				n += nn
				if err != nil {
					return n, err
				}
			}
		} else {
			for _, attr := range tag {
				nn, err := attr.(io.WriterTo).WriteTo(w)
				n += nn
				if err != nil {
					return n, err
				}
			}
		}
	}

	nn, err = fmt.Fprintf(w, ">")
	n += int64(nn)
	if err != nil {
		return n, err
	}

	if children && idx >= 0 {
		for _, child := range tag[idx:] {
			nn, err := render(w, child)
			n += nn
			if err != nil {
				return n, err
			}
		}
	}

	nn, err = fmt.Fprintf(w, "</search>")
	n += int64(nn)

	return n, nil
}
func (tag Search) element() {}
func (tag Search) Reader() io.Reader {
	r, w := io.Pipe()
	go func(w *io.PipeWriter) {
		_, err := tag.WriteTo(w)
		if err != nil {
			w.CloseWithError(err)
		} else {
			w.Close()
		}
	}(w)
	return r
}
func (tag Search) String() string {
	b := strings.Builder{}
	tag.WriteTo(&b)
	return b.String()
}
func (tag Search) Bytes() []byte {
	b := bytes.Buffer{}
	tag.WriteTo(&b)
	return b.Bytes()
}


type Section []any

func (tag Section) WriteTo(w io.Writer) (int64, error) {
	n := int64(0)

	nn, err := fmt.Fprintf(w, "<section")
	n += int64(nn)
	if err != nil {
		return n, err
	}

	children := len(tag) > 0
	idx := 0

	if children {
		slices.SortStableFunc(tag, sort)
		idx = slices.IndexFunc(tag, index)

		if idx >= 0 {
			for _, attr := range tag[:idx] {
				nn, err := attr.(io.WriterTo).WriteTo(w)
				n += nn
				if err != nil {
					return n, err
				}
			}
		} else {
			for _, attr := range tag {
				nn, err := attr.(io.WriterTo).WriteTo(w)
				n += nn
				if err != nil {
					return n, err
				}
			}
		}
	}

	nn, err = fmt.Fprintf(w, ">")
	n += int64(nn)
	if err != nil {
		return n, err
	}

	if children && idx >= 0 {
		for _, child := range tag[idx:] {
			nn, err := render(w, child)
			n += nn
			if err != nil {
				return n, err
			}
		}
	}

	nn, err = fmt.Fprintf(w, "</section>")
	n += int64(nn)

	return n, nil
}
func (tag Section) element() {}
func (tag Section) Reader() io.Reader {
	r, w := io.Pipe()
	go func(w *io.PipeWriter) {
		_, err := tag.WriteTo(w)
		if err != nil {
			w.CloseWithError(err)
		} else {
			w.Close()
		}
	}(w)
	return r
}
func (tag Section) String() string {
	b := strings.Builder{}
	tag.WriteTo(&b)
	return b.String()
}
func (tag Section) Bytes() []byte {
	b := bytes.Buffer{}
	tag.WriteTo(&b)
	return b.Bytes()
}


type Select []any

func (tag Select) WriteTo(w io.Writer) (int64, error) {
	n := int64(0)

	nn, err := fmt.Fprintf(w, "<select")
	n += int64(nn)
	if err != nil {
		return n, err
	}

	children := len(tag) > 0
	idx := 0

	if children {
		slices.SortStableFunc(tag, sort)
		idx = slices.IndexFunc(tag, index)

		if idx >= 0 {
			for _, attr := range tag[:idx] {
				nn, err := attr.(io.WriterTo).WriteTo(w)
				n += nn
				if err != nil {
					return n, err
				}
			}
		} else {
			for _, attr := range tag {
				nn, err := attr.(io.WriterTo).WriteTo(w)
				n += nn
				if err != nil {
					return n, err
				}
			}
		}
	}

	nn, err = fmt.Fprintf(w, ">")
	n += int64(nn)
	if err != nil {
		return n, err
	}

	if children && idx >= 0 {
		for _, child := range tag[idx:] {
			nn, err := render(w, child)
			n += nn
			if err != nil {
				return n, err
			}
		}
	}

	nn, err = fmt.Fprintf(w, "</select>")
	n += int64(nn)

	return n, nil
}
func (tag Select) element() {}
func (tag Select) Reader() io.Reader {
	r, w := io.Pipe()
	go func(w *io.PipeWriter) {
		_, err := tag.WriteTo(w)
		if err != nil {
			w.CloseWithError(err)
		} else {
			w.Close()
		}
	}(w)
	return r
}
func (tag Select) String() string {
	b := strings.Builder{}
	tag.WriteTo(&b)
	return b.String()
}
func (tag Select) Bytes() []byte {
	b := bytes.Buffer{}
	tag.WriteTo(&b)
	return b.Bytes()
}


type Slot []any

func (tag Slot) WriteTo(w io.Writer) (int64, error) {
	n := int64(0)

	nn, err := fmt.Fprintf(w, "<slot")
	n += int64(nn)
	if err != nil {
		return n, err
	}

	children := len(tag) > 0
	idx := 0

	if children {
		slices.SortStableFunc(tag, sort)
		idx = slices.IndexFunc(tag, index)

		if idx >= 0 {
			for _, attr := range tag[:idx] {
				nn, err := attr.(io.WriterTo).WriteTo(w)
				n += nn
				if err != nil {
					return n, err
				}
			}
		} else {
			for _, attr := range tag {
				nn, err := attr.(io.WriterTo).WriteTo(w)
				n += nn
				if err != nil {
					return n, err
				}
			}
		}
	}

	nn, err = fmt.Fprintf(w, ">")
	n += int64(nn)
	if err != nil {
		return n, err
	}

	if children && idx >= 0 {
		for _, child := range tag[idx:] {
			nn, err := render(w, child)
			n += nn
			if err != nil {
				return n, err
			}
		}
	}

	nn, err = fmt.Fprintf(w, "</slot>")
	n += int64(nn)

	return n, nil
}
func (tag Slot) element() {}
func (tag Slot) Reader() io.Reader {
	r, w := io.Pipe()
	go func(w *io.PipeWriter) {
		_, err := tag.WriteTo(w)
		if err != nil {
			w.CloseWithError(err)
		} else {
			w.Close()
		}
	}(w)
	return r
}
func (tag Slot) String() string {
	b := strings.Builder{}
	tag.WriteTo(&b)
	return b.String()
}
func (tag Slot) Bytes() []byte {
	b := bytes.Buffer{}
	tag.WriteTo(&b)
	return b.Bytes()
}


type Small []any

func (tag Small) WriteTo(w io.Writer) (int64, error) {
	n := int64(0)

	nn, err := fmt.Fprintf(w, "<small")
	n += int64(nn)
	if err != nil {
		return n, err
	}

	children := len(tag) > 0
	idx := 0

	if children {
		slices.SortStableFunc(tag, sort)
		idx = slices.IndexFunc(tag, index)

		if idx >= 0 {
			for _, attr := range tag[:idx] {
				nn, err := attr.(io.WriterTo).WriteTo(w)
				n += nn
				if err != nil {
					return n, err
				}
			}
		} else {
			for _, attr := range tag {
				nn, err := attr.(io.WriterTo).WriteTo(w)
				n += nn
				if err != nil {
					return n, err
				}
			}
		}
	}

	nn, err = fmt.Fprintf(w, ">")
	n += int64(nn)
	if err != nil {
		return n, err
	}

	if children && idx >= 0 {
		for _, child := range tag[idx:] {
			nn, err := render(w, child)
			n += nn
			if err != nil {
				return n, err
			}
		}
	}

	nn, err = fmt.Fprintf(w, "</small>")
	n += int64(nn)

	return n, nil
}
func (tag Small) element() {}
func (tag Small) Reader() io.Reader {
	r, w := io.Pipe()
	go func(w *io.PipeWriter) {
		_, err := tag.WriteTo(w)
		if err != nil {
			w.CloseWithError(err)
		} else {
			w.Close()
		}
	}(w)
	return r
}
func (tag Small) String() string {
	b := strings.Builder{}
	tag.WriteTo(&b)
	return b.String()
}
func (tag Small) Bytes() []byte {
	b := bytes.Buffer{}
	tag.WriteTo(&b)
	return b.Bytes()
}


type Source baseAttrs

func (tag Source) WriteTo(w io.Writer) (int64, error) {
	n := int64(0)

	nn, err := toInt64Error(fmt.Fprintf(w, "<source"))
	n += int64(nn)
	if err != nil {
		return n, err
	}

	nn, err = baseAttrs(tag).WriteTo(w)
	n += nn
	if err != nil {
		return n, err
	}

	nn, err = toInt64Error(fmt.Fprintf(w, "/>"))
	n += int64(nn)
	return n, err
}
func (tag Source) element() {}
func (tag Source) Reader() io.Reader {
	r, w := io.Pipe()
	go func(w *io.PipeWriter) {
		_, err := tag.WriteTo(w)
		if err != nil {
			w.CloseWithError(err)
		} else {
			w.Close()
		}
	}(w)
	return r
}
func (tag Source) String() string {
	b := strings.Builder{}
	tag.WriteTo(&b)
	return b.String()
}
func (tag Source) Bytes() []byte {
	b := bytes.Buffer{}
	tag.WriteTo(&b)
	return b.Bytes()
}


type Span []any

func (tag Span) WriteTo(w io.Writer) (int64, error) {
	n := int64(0)

	nn, err := fmt.Fprintf(w, "<span")
	n += int64(nn)
	if err != nil {
		return n, err
	}

	children := len(tag) > 0
	idx := 0

	if children {
		slices.SortStableFunc(tag, sort)
		idx = slices.IndexFunc(tag, index)

		if idx >= 0 {
			for _, attr := range tag[:idx] {
				nn, err := attr.(io.WriterTo).WriteTo(w)
				n += nn
				if err != nil {
					return n, err
				}
			}
		} else {
			for _, attr := range tag {
				nn, err := attr.(io.WriterTo).WriteTo(w)
				n += nn
				if err != nil {
					return n, err
				}
			}
		}
	}

	nn, err = fmt.Fprintf(w, ">")
	n += int64(nn)
	if err != nil {
		return n, err
	}

	if children && idx >= 0 {
		for _, child := range tag[idx:] {
			nn, err := render(w, child)
			n += nn
			if err != nil {
				return n, err
			}
		}
	}

	nn, err = fmt.Fprintf(w, "</span>")
	n += int64(nn)

	return n, nil
}
func (tag Span) element() {}
func (tag Span) Reader() io.Reader {
	r, w := io.Pipe()
	go func(w *io.PipeWriter) {
		_, err := tag.WriteTo(w)
		if err != nil {
			w.CloseWithError(err)
		} else {
			w.Close()
		}
	}(w)
	return r
}
func (tag Span) String() string {
	b := strings.Builder{}
	tag.WriteTo(&b)
	return b.String()
}
func (tag Span) Bytes() []byte {
	b := bytes.Buffer{}
	tag.WriteTo(&b)
	return b.Bytes()
}


type Strong []any

func (tag Strong) WriteTo(w io.Writer) (int64, error) {
	n := int64(0)

	nn, err := fmt.Fprintf(w, "<strong")
	n += int64(nn)
	if err != nil {
		return n, err
	}

	children := len(tag) > 0
	idx := 0

	if children {
		slices.SortStableFunc(tag, sort)
		idx = slices.IndexFunc(tag, index)

		if idx >= 0 {
			for _, attr := range tag[:idx] {
				nn, err := attr.(io.WriterTo).WriteTo(w)
				n += nn
				if err != nil {
					return n, err
				}
			}
		} else {
			for _, attr := range tag {
				nn, err := attr.(io.WriterTo).WriteTo(w)
				n += nn
				if err != nil {
					return n, err
				}
			}
		}
	}

	nn, err = fmt.Fprintf(w, ">")
	n += int64(nn)
	if err != nil {
		return n, err
	}

	if children && idx >= 0 {
		for _, child := range tag[idx:] {
			nn, err := render(w, child)
			n += nn
			if err != nil {
				return n, err
			}
		}
	}

	nn, err = fmt.Fprintf(w, "</strong>")
	n += int64(nn)

	return n, nil
}
func (tag Strong) element() {}
func (tag Strong) Reader() io.Reader {
	r, w := io.Pipe()
	go func(w *io.PipeWriter) {
		_, err := tag.WriteTo(w)
		if err != nil {
			w.CloseWithError(err)
		} else {
			w.Close()
		}
	}(w)
	return r
}
func (tag Strong) String() string {
	b := strings.Builder{}
	tag.WriteTo(&b)
	return b.String()
}
func (tag Strong) Bytes() []byte {
	b := bytes.Buffer{}
	tag.WriteTo(&b)
	return b.Bytes()
}


type Style []any

func (tag Style) WriteTo(w io.Writer) (int64, error) {
	n := int64(0)

	nn, err := fmt.Fprintf(w, "<style")
	n += int64(nn)
	if err != nil {
		return n, err
	}

	children := len(tag) > 0
	idx := 0

	if children {
		slices.SortStableFunc(tag, sort)
		idx = slices.IndexFunc(tag, index)

		if idx >= 0 {
			for _, attr := range tag[:idx] {
				nn, err := attr.(io.WriterTo).WriteTo(w)
				n += nn
				if err != nil {
					return n, err
				}
			}
		} else {
			for _, attr := range tag {
				nn, err := attr.(io.WriterTo).WriteTo(w)
				n += nn
				if err != nil {
					return n, err
				}
			}
		}
	}

	nn, err = fmt.Fprintf(w, ">")
	n += int64(nn)
	if err != nil {
		return n, err
	}

	if children && idx >= 0 {
		for _, child := range tag[idx:] {
			nn, err := render(w, child)
			n += nn
			if err != nil {
				return n, err
			}
		}
	}

	nn, err = fmt.Fprintf(w, "</style>")
	n += int64(nn)

	return n, nil
}
func (tag Style) element() {}
func (tag Style) Reader() io.Reader {
	r, w := io.Pipe()
	go func(w *io.PipeWriter) {
		_, err := tag.WriteTo(w)
		if err != nil {
			w.CloseWithError(err)
		} else {
			w.Close()
		}
	}(w)
	return r
}
func (tag Style) String() string {
	b := strings.Builder{}
	tag.WriteTo(&b)
	return b.String()
}
func (tag Style) Bytes() []byte {
	b := bytes.Buffer{}
	tag.WriteTo(&b)
	return b.Bytes()
}


type Sub []any

func (tag Sub) WriteTo(w io.Writer) (int64, error) {
	n := int64(0)

	nn, err := fmt.Fprintf(w, "<sub")
	n += int64(nn)
	if err != nil {
		return n, err
	}

	children := len(tag) > 0
	idx := 0

	if children {
		slices.SortStableFunc(tag, sort)
		idx = slices.IndexFunc(tag, index)

		if idx >= 0 {
			for _, attr := range tag[:idx] {
				nn, err := attr.(io.WriterTo).WriteTo(w)
				n += nn
				if err != nil {
					return n, err
				}
			}
		} else {
			for _, attr := range tag {
				nn, err := attr.(io.WriterTo).WriteTo(w)
				n += nn
				if err != nil {
					return n, err
				}
			}
		}
	}

	nn, err = fmt.Fprintf(w, ">")
	n += int64(nn)
	if err != nil {
		return n, err
	}

	if children && idx >= 0 {
		for _, child := range tag[idx:] {
			nn, err := render(w, child)
			n += nn
			if err != nil {
				return n, err
			}
		}
	}

	nn, err = fmt.Fprintf(w, "</sub>")
	n += int64(nn)

	return n, nil
}
func (tag Sub) element() {}
func (tag Sub) Reader() io.Reader {
	r, w := io.Pipe()
	go func(w *io.PipeWriter) {
		_, err := tag.WriteTo(w)
		if err != nil {
			w.CloseWithError(err)
		} else {
			w.Close()
		}
	}(w)
	return r
}
func (tag Sub) String() string {
	b := strings.Builder{}
	tag.WriteTo(&b)
	return b.String()
}
func (tag Sub) Bytes() []byte {
	b := bytes.Buffer{}
	tag.WriteTo(&b)
	return b.Bytes()
}


type Summary []any

func (tag Summary) WriteTo(w io.Writer) (int64, error) {
	n := int64(0)

	nn, err := fmt.Fprintf(w, "<summary")
	n += int64(nn)
	if err != nil {
		return n, err
	}

	children := len(tag) > 0
	idx := 0

	if children {
		slices.SortStableFunc(tag, sort)
		idx = slices.IndexFunc(tag, index)

		if idx >= 0 {
			for _, attr := range tag[:idx] {
				nn, err := attr.(io.WriterTo).WriteTo(w)
				n += nn
				if err != nil {
					return n, err
				}
			}
		} else {
			for _, attr := range tag {
				nn, err := attr.(io.WriterTo).WriteTo(w)
				n += nn
				if err != nil {
					return n, err
				}
			}
		}
	}

	nn, err = fmt.Fprintf(w, ">")
	n += int64(nn)
	if err != nil {
		return n, err
	}

	if children && idx >= 0 {
		for _, child := range tag[idx:] {
			nn, err := render(w, child)
			n += nn
			if err != nil {
				return n, err
			}
		}
	}

	nn, err = fmt.Fprintf(w, "</summary>")
	n += int64(nn)

	return n, nil
}
func (tag Summary) element() {}
func (tag Summary) Reader() io.Reader {
	r, w := io.Pipe()
	go func(w *io.PipeWriter) {
		_, err := tag.WriteTo(w)
		if err != nil {
			w.CloseWithError(err)
		} else {
			w.Close()
		}
	}(w)
	return r
}
func (tag Summary) String() string {
	b := strings.Builder{}
	tag.WriteTo(&b)
	return b.String()
}
func (tag Summary) Bytes() []byte {
	b := bytes.Buffer{}
	tag.WriteTo(&b)
	return b.Bytes()
}


type Sup []any

func (tag Sup) WriteTo(w io.Writer) (int64, error) {
	n := int64(0)

	nn, err := fmt.Fprintf(w, "<sup")
	n += int64(nn)
	if err != nil {
		return n, err
	}

	children := len(tag) > 0
	idx := 0

	if children {
		slices.SortStableFunc(tag, sort)
		idx = slices.IndexFunc(tag, index)

		if idx >= 0 {
			for _, attr := range tag[:idx] {
				nn, err := attr.(io.WriterTo).WriteTo(w)
				n += nn
				if err != nil {
					return n, err
				}
			}
		} else {
			for _, attr := range tag {
				nn, err := attr.(io.WriterTo).WriteTo(w)
				n += nn
				if err != nil {
					return n, err
				}
			}
		}
	}

	nn, err = fmt.Fprintf(w, ">")
	n += int64(nn)
	if err != nil {
		return n, err
	}

	if children && idx >= 0 {
		for _, child := range tag[idx:] {
			nn, err := render(w, child)
			n += nn
			if err != nil {
				return n, err
			}
		}
	}

	nn, err = fmt.Fprintf(w, "</sup>")
	n += int64(nn)

	return n, nil
}
func (tag Sup) element() {}
func (tag Sup) Reader() io.Reader {
	r, w := io.Pipe()
	go func(w *io.PipeWriter) {
		_, err := tag.WriteTo(w)
		if err != nil {
			w.CloseWithError(err)
		} else {
			w.Close()
		}
	}(w)
	return r
}
func (tag Sup) String() string {
	b := strings.Builder{}
	tag.WriteTo(&b)
	return b.String()
}
func (tag Sup) Bytes() []byte {
	b := bytes.Buffer{}
	tag.WriteTo(&b)
	return b.Bytes()
}


type Svg []any

func (tag Svg) WriteTo(w io.Writer) (int64, error) {
	n := int64(0)

	nn, err := fmt.Fprintf(w, "<svg")
	n += int64(nn)
	if err != nil {
		return n, err
	}

	children := len(tag) > 0
	idx := 0

	if children {
		slices.SortStableFunc(tag, sort)
		idx = slices.IndexFunc(tag, index)

		if idx >= 0 {
			for _, attr := range tag[:idx] {
				nn, err := attr.(io.WriterTo).WriteTo(w)
				n += nn
				if err != nil {
					return n, err
				}
			}
		} else {
			for _, attr := range tag {
				nn, err := attr.(io.WriterTo).WriteTo(w)
				n += nn
				if err != nil {
					return n, err
				}
			}
		}
	}

	nn, err = fmt.Fprintf(w, ">")
	n += int64(nn)
	if err != nil {
		return n, err
	}

	if children && idx >= 0 {
		for _, child := range tag[idx:] {
			nn, err := render(w, child)
			n += nn
			if err != nil {
				return n, err
			}
		}
	}

	nn, err = fmt.Fprintf(w, "</svg>")
	n += int64(nn)

	return n, nil
}
func (tag Svg) element() {}
func (tag Svg) Reader() io.Reader {
	r, w := io.Pipe()
	go func(w *io.PipeWriter) {
		_, err := tag.WriteTo(w)
		if err != nil {
			w.CloseWithError(err)
		} else {
			w.Close()
		}
	}(w)
	return r
}
func (tag Svg) String() string {
	b := strings.Builder{}
	tag.WriteTo(&b)
	return b.String()
}
func (tag Svg) Bytes() []byte {
	b := bytes.Buffer{}
	tag.WriteTo(&b)
	return b.Bytes()
}


type Table []any

func (tag Table) WriteTo(w io.Writer) (int64, error) {
	n := int64(0)

	nn, err := fmt.Fprintf(w, "<table")
	n += int64(nn)
	if err != nil {
		return n, err
	}

	children := len(tag) > 0
	idx := 0

	if children {
		slices.SortStableFunc(tag, sort)
		idx = slices.IndexFunc(tag, index)

		if idx >= 0 {
			for _, attr := range tag[:idx] {
				nn, err := attr.(io.WriterTo).WriteTo(w)
				n += nn
				if err != nil {
					return n, err
				}
			}
		} else {
			for _, attr := range tag {
				nn, err := attr.(io.WriterTo).WriteTo(w)
				n += nn
				if err != nil {
					return n, err
				}
			}
		}
	}

	nn, err = fmt.Fprintf(w, ">")
	n += int64(nn)
	if err != nil {
		return n, err
	}

	if children && idx >= 0 {
		for _, child := range tag[idx:] {
			nn, err := render(w, child)
			n += nn
			if err != nil {
				return n, err
			}
		}
	}

	nn, err = fmt.Fprintf(w, "</table>")
	n += int64(nn)

	return n, nil
}
func (tag Table) element() {}
func (tag Table) Reader() io.Reader {
	r, w := io.Pipe()
	go func(w *io.PipeWriter) {
		_, err := tag.WriteTo(w)
		if err != nil {
			w.CloseWithError(err)
		} else {
			w.Close()
		}
	}(w)
	return r
}
func (tag Table) String() string {
	b := strings.Builder{}
	tag.WriteTo(&b)
	return b.String()
}
func (tag Table) Bytes() []byte {
	b := bytes.Buffer{}
	tag.WriteTo(&b)
	return b.Bytes()
}


type Tbody []any

func (tag Tbody) WriteTo(w io.Writer) (int64, error) {
	n := int64(0)

	nn, err := fmt.Fprintf(w, "<tbody")
	n += int64(nn)
	if err != nil {
		return n, err
	}

	children := len(tag) > 0
	idx := 0

	if children {
		slices.SortStableFunc(tag, sort)
		idx = slices.IndexFunc(tag, index)

		if idx >= 0 {
			for _, attr := range tag[:idx] {
				nn, err := attr.(io.WriterTo).WriteTo(w)
				n += nn
				if err != nil {
					return n, err
				}
			}
		} else {
			for _, attr := range tag {
				nn, err := attr.(io.WriterTo).WriteTo(w)
				n += nn
				if err != nil {
					return n, err
				}
			}
		}
	}

	nn, err = fmt.Fprintf(w, ">")
	n += int64(nn)
	if err != nil {
		return n, err
	}

	if children && idx >= 0 {
		for _, child := range tag[idx:] {
			nn, err := render(w, child)
			n += nn
			if err != nil {
				return n, err
			}
		}
	}

	nn, err = fmt.Fprintf(w, "</tbody>")
	n += int64(nn)

	return n, nil
}
func (tag Tbody) element() {}
func (tag Tbody) Reader() io.Reader {
	r, w := io.Pipe()
	go func(w *io.PipeWriter) {
		_, err := tag.WriteTo(w)
		if err != nil {
			w.CloseWithError(err)
		} else {
			w.Close()
		}
	}(w)
	return r
}
func (tag Tbody) String() string {
	b := strings.Builder{}
	tag.WriteTo(&b)
	return b.String()
}
func (tag Tbody) Bytes() []byte {
	b := bytes.Buffer{}
	tag.WriteTo(&b)
	return b.Bytes()
}


type Td []any

func (tag Td) WriteTo(w io.Writer) (int64, error) {
	n := int64(0)

	nn, err := fmt.Fprintf(w, "<td")
	n += int64(nn)
	if err != nil {
		return n, err
	}

	children := len(tag) > 0
	idx := 0

	if children {
		slices.SortStableFunc(tag, sort)
		idx = slices.IndexFunc(tag, index)

		if idx >= 0 {
			for _, attr := range tag[:idx] {
				nn, err := attr.(io.WriterTo).WriteTo(w)
				n += nn
				if err != nil {
					return n, err
				}
			}
		} else {
			for _, attr := range tag {
				nn, err := attr.(io.WriterTo).WriteTo(w)
				n += nn
				if err != nil {
					return n, err
				}
			}
		}
	}

	nn, err = fmt.Fprintf(w, ">")
	n += int64(nn)
	if err != nil {
		return n, err
	}

	if children && idx >= 0 {
		for _, child := range tag[idx:] {
			nn, err := render(w, child)
			n += nn
			if err != nil {
				return n, err
			}
		}
	}

	nn, err = fmt.Fprintf(w, "</td>")
	n += int64(nn)

	return n, nil
}
func (tag Td) element() {}
func (tag Td) Reader() io.Reader {
	r, w := io.Pipe()
	go func(w *io.PipeWriter) {
		_, err := tag.WriteTo(w)
		if err != nil {
			w.CloseWithError(err)
		} else {
			w.Close()
		}
	}(w)
	return r
}
func (tag Td) String() string {
	b := strings.Builder{}
	tag.WriteTo(&b)
	return b.String()
}
func (tag Td) Bytes() []byte {
	b := bytes.Buffer{}
	tag.WriteTo(&b)
	return b.Bytes()
}


type Template []any

func (tag Template) WriteTo(w io.Writer) (int64, error) {
	n := int64(0)

	nn, err := fmt.Fprintf(w, "<template")
	n += int64(nn)
	if err != nil {
		return n, err
	}

	children := len(tag) > 0
	idx := 0

	if children {
		slices.SortStableFunc(tag, sort)
		idx = slices.IndexFunc(tag, index)

		if idx >= 0 {
			for _, attr := range tag[:idx] {
				nn, err := attr.(io.WriterTo).WriteTo(w)
				n += nn
				if err != nil {
					return n, err
				}
			}
		} else {
			for _, attr := range tag {
				nn, err := attr.(io.WriterTo).WriteTo(w)
				n += nn
				if err != nil {
					return n, err
				}
			}
		}
	}

	nn, err = fmt.Fprintf(w, ">")
	n += int64(nn)
	if err != nil {
		return n, err
	}

	if children && idx >= 0 {
		for _, child := range tag[idx:] {
			nn, err := render(w, child)
			n += nn
			if err != nil {
				return n, err
			}
		}
	}

	nn, err = fmt.Fprintf(w, "</template>")
	n += int64(nn)

	return n, nil
}
func (tag Template) element() {}
func (tag Template) Reader() io.Reader {
	r, w := io.Pipe()
	go func(w *io.PipeWriter) {
		_, err := tag.WriteTo(w)
		if err != nil {
			w.CloseWithError(err)
		} else {
			w.Close()
		}
	}(w)
	return r
}
func (tag Template) String() string {
	b := strings.Builder{}
	tag.WriteTo(&b)
	return b.String()
}
func (tag Template) Bytes() []byte {
	b := bytes.Buffer{}
	tag.WriteTo(&b)
	return b.Bytes()
}


type Textarea []any

func (tag Textarea) WriteTo(w io.Writer) (int64, error) {
	n := int64(0)

	nn, err := fmt.Fprintf(w, "<textarea")
	n += int64(nn)
	if err != nil {
		return n, err
	}

	children := len(tag) > 0
	idx := 0

	if children {
		slices.SortStableFunc(tag, sort)
		idx = slices.IndexFunc(tag, index)

		if idx >= 0 {
			for _, attr := range tag[:idx] {
				nn, err := attr.(io.WriterTo).WriteTo(w)
				n += nn
				if err != nil {
					return n, err
				}
			}
		} else {
			for _, attr := range tag {
				nn, err := attr.(io.WriterTo).WriteTo(w)
				n += nn
				if err != nil {
					return n, err
				}
			}
		}
	}

	nn, err = fmt.Fprintf(w, ">")
	n += int64(nn)
	if err != nil {
		return n, err
	}

	if children && idx >= 0 {
		for _, child := range tag[idx:] {
			nn, err := render(w, child)
			n += nn
			if err != nil {
				return n, err
			}
		}
	}

	nn, err = fmt.Fprintf(w, "</textarea>")
	n += int64(nn)

	return n, nil
}
func (tag Textarea) element() {}
func (tag Textarea) Reader() io.Reader {
	r, w := io.Pipe()
	go func(w *io.PipeWriter) {
		_, err := tag.WriteTo(w)
		if err != nil {
			w.CloseWithError(err)
		} else {
			w.Close()
		}
	}(w)
	return r
}
func (tag Textarea) String() string {
	b := strings.Builder{}
	tag.WriteTo(&b)
	return b.String()
}
func (tag Textarea) Bytes() []byte {
	b := bytes.Buffer{}
	tag.WriteTo(&b)
	return b.Bytes()
}


type Tfoot []any

func (tag Tfoot) WriteTo(w io.Writer) (int64, error) {
	n := int64(0)

	nn, err := fmt.Fprintf(w, "<tfoot")
	n += int64(nn)
	if err != nil {
		return n, err
	}

	children := len(tag) > 0
	idx := 0

	if children {
		slices.SortStableFunc(tag, sort)
		idx = slices.IndexFunc(tag, index)

		if idx >= 0 {
			for _, attr := range tag[:idx] {
				nn, err := attr.(io.WriterTo).WriteTo(w)
				n += nn
				if err != nil {
					return n, err
				}
			}
		} else {
			for _, attr := range tag {
				nn, err := attr.(io.WriterTo).WriteTo(w)
				n += nn
				if err != nil {
					return n, err
				}
			}
		}
	}

	nn, err = fmt.Fprintf(w, ">")
	n += int64(nn)
	if err != nil {
		return n, err
	}

	if children && idx >= 0 {
		for _, child := range tag[idx:] {
			nn, err := render(w, child)
			n += nn
			if err != nil {
				return n, err
			}
		}
	}

	nn, err = fmt.Fprintf(w, "</tfoot>")
	n += int64(nn)

	return n, nil
}
func (tag Tfoot) element() {}
func (tag Tfoot) Reader() io.Reader {
	r, w := io.Pipe()
	go func(w *io.PipeWriter) {
		_, err := tag.WriteTo(w)
		if err != nil {
			w.CloseWithError(err)
		} else {
			w.Close()
		}
	}(w)
	return r
}
func (tag Tfoot) String() string {
	b := strings.Builder{}
	tag.WriteTo(&b)
	return b.String()
}
func (tag Tfoot) Bytes() []byte {
	b := bytes.Buffer{}
	tag.WriteTo(&b)
	return b.Bytes()
}


type Th []any

func (tag Th) WriteTo(w io.Writer) (int64, error) {
	n := int64(0)

	nn, err := fmt.Fprintf(w, "<th")
	n += int64(nn)
	if err != nil {
		return n, err
	}

	children := len(tag) > 0
	idx := 0

	if children {
		slices.SortStableFunc(tag, sort)
		idx = slices.IndexFunc(tag, index)

		if idx >= 0 {
			for _, attr := range tag[:idx] {
				nn, err := attr.(io.WriterTo).WriteTo(w)
				n += nn
				if err != nil {
					return n, err
				}
			}
		} else {
			for _, attr := range tag {
				nn, err := attr.(io.WriterTo).WriteTo(w)
				n += nn
				if err != nil {
					return n, err
				}
			}
		}
	}

	nn, err = fmt.Fprintf(w, ">")
	n += int64(nn)
	if err != nil {
		return n, err
	}

	if children && idx >= 0 {
		for _, child := range tag[idx:] {
			nn, err := render(w, child)
			n += nn
			if err != nil {
				return n, err
			}
		}
	}

	nn, err = fmt.Fprintf(w, "</th>")
	n += int64(nn)

	return n, nil
}
func (tag Th) element() {}
func (tag Th) Reader() io.Reader {
	r, w := io.Pipe()
	go func(w *io.PipeWriter) {
		_, err := tag.WriteTo(w)
		if err != nil {
			w.CloseWithError(err)
		} else {
			w.Close()
		}
	}(w)
	return r
}
func (tag Th) String() string {
	b := strings.Builder{}
	tag.WriteTo(&b)
	return b.String()
}
func (tag Th) Bytes() []byte {
	b := bytes.Buffer{}
	tag.WriteTo(&b)
	return b.Bytes()
}


type Thead []any

func (tag Thead) WriteTo(w io.Writer) (int64, error) {
	n := int64(0)

	nn, err := fmt.Fprintf(w, "<thead")
	n += int64(nn)
	if err != nil {
		return n, err
	}

	children := len(tag) > 0
	idx := 0

	if children {
		slices.SortStableFunc(tag, sort)
		idx = slices.IndexFunc(tag, index)

		if idx >= 0 {
			for _, attr := range tag[:idx] {
				nn, err := attr.(io.WriterTo).WriteTo(w)
				n += nn
				if err != nil {
					return n, err
				}
			}
		} else {
			for _, attr := range tag {
				nn, err := attr.(io.WriterTo).WriteTo(w)
				n += nn
				if err != nil {
					return n, err
				}
			}
		}
	}

	nn, err = fmt.Fprintf(w, ">")
	n += int64(nn)
	if err != nil {
		return n, err
	}

	if children && idx >= 0 {
		for _, child := range tag[idx:] {
			nn, err := render(w, child)
			n += nn
			if err != nil {
				return n, err
			}
		}
	}

	nn, err = fmt.Fprintf(w, "</thead>")
	n += int64(nn)

	return n, nil
}
func (tag Thead) element() {}
func (tag Thead) Reader() io.Reader {
	r, w := io.Pipe()
	go func(w *io.PipeWriter) {
		_, err := tag.WriteTo(w)
		if err != nil {
			w.CloseWithError(err)
		} else {
			w.Close()
		}
	}(w)
	return r
}
func (tag Thead) String() string {
	b := strings.Builder{}
	tag.WriteTo(&b)
	return b.String()
}
func (tag Thead) Bytes() []byte {
	b := bytes.Buffer{}
	tag.WriteTo(&b)
	return b.Bytes()
}


type Time []any

func (tag Time) WriteTo(w io.Writer) (int64, error) {
	n := int64(0)

	nn, err := fmt.Fprintf(w, "<time")
	n += int64(nn)
	if err != nil {
		return n, err
	}

	children := len(tag) > 0
	idx := 0

	if children {
		slices.SortStableFunc(tag, sort)
		idx = slices.IndexFunc(tag, index)

		if idx >= 0 {
			for _, attr := range tag[:idx] {
				nn, err := attr.(io.WriterTo).WriteTo(w)
				n += nn
				if err != nil {
					return n, err
				}
			}
		} else {
			for _, attr := range tag {
				nn, err := attr.(io.WriterTo).WriteTo(w)
				n += nn
				if err != nil {
					return n, err
				}
			}
		}
	}

	nn, err = fmt.Fprintf(w, ">")
	n += int64(nn)
	if err != nil {
		return n, err
	}

	if children && idx >= 0 {
		for _, child := range tag[idx:] {
			nn, err := render(w, child)
			n += nn
			if err != nil {
				return n, err
			}
		}
	}

	nn, err = fmt.Fprintf(w, "</time>")
	n += int64(nn)

	return n, nil
}
func (tag Time) element() {}
func (tag Time) Reader() io.Reader {
	r, w := io.Pipe()
	go func(w *io.PipeWriter) {
		_, err := tag.WriteTo(w)
		if err != nil {
			w.CloseWithError(err)
		} else {
			w.Close()
		}
	}(w)
	return r
}
func (tag Time) String() string {
	b := strings.Builder{}
	tag.WriteTo(&b)
	return b.String()
}
func (tag Time) Bytes() []byte {
	b := bytes.Buffer{}
	tag.WriteTo(&b)
	return b.Bytes()
}


type Title []any

func (tag Title) WriteTo(w io.Writer) (int64, error) {
	n := int64(0)

	nn, err := fmt.Fprintf(w, "<title")
	n += int64(nn)
	if err != nil {
		return n, err
	}

	children := len(tag) > 0
	idx := 0

	if children {
		slices.SortStableFunc(tag, sort)
		idx = slices.IndexFunc(tag, index)

		if idx >= 0 {
			for _, attr := range tag[:idx] {
				nn, err := attr.(io.WriterTo).WriteTo(w)
				n += nn
				if err != nil {
					return n, err
				}
			}
		} else {
			for _, attr := range tag {
				nn, err := attr.(io.WriterTo).WriteTo(w)
				n += nn
				if err != nil {
					return n, err
				}
			}
		}
	}

	nn, err = fmt.Fprintf(w, ">")
	n += int64(nn)
	if err != nil {
		return n, err
	}

	if children && idx >= 0 {
		for _, child := range tag[idx:] {
			nn, err := render(w, child)
			n += nn
			if err != nil {
				return n, err
			}
		}
	}

	nn, err = fmt.Fprintf(w, "</title>")
	n += int64(nn)

	return n, nil
}
func (tag Title) element() {}
func (tag Title) Reader() io.Reader {
	r, w := io.Pipe()
	go func(w *io.PipeWriter) {
		_, err := tag.WriteTo(w)
		if err != nil {
			w.CloseWithError(err)
		} else {
			w.Close()
		}
	}(w)
	return r
}
func (tag Title) String() string {
	b := strings.Builder{}
	tag.WriteTo(&b)
	return b.String()
}
func (tag Title) Bytes() []byte {
	b := bytes.Buffer{}
	tag.WriteTo(&b)
	return b.Bytes()
}


type Tr []any

func (tag Tr) WriteTo(w io.Writer) (int64, error) {
	n := int64(0)

	nn, err := fmt.Fprintf(w, "<tr")
	n += int64(nn)
	if err != nil {
		return n, err
	}

	children := len(tag) > 0
	idx := 0

	if children {
		slices.SortStableFunc(tag, sort)
		idx = slices.IndexFunc(tag, index)

		if idx >= 0 {
			for _, attr := range tag[:idx] {
				nn, err := attr.(io.WriterTo).WriteTo(w)
				n += nn
				if err != nil {
					return n, err
				}
			}
		} else {
			for _, attr := range tag {
				nn, err := attr.(io.WriterTo).WriteTo(w)
				n += nn
				if err != nil {
					return n, err
				}
			}
		}
	}

	nn, err = fmt.Fprintf(w, ">")
	n += int64(nn)
	if err != nil {
		return n, err
	}

	if children && idx >= 0 {
		for _, child := range tag[idx:] {
			nn, err := render(w, child)
			n += nn
			if err != nil {
				return n, err
			}
		}
	}

	nn, err = fmt.Fprintf(w, "</tr>")
	n += int64(nn)

	return n, nil
}
func (tag Tr) element() {}
func (tag Tr) Reader() io.Reader {
	r, w := io.Pipe()
	go func(w *io.PipeWriter) {
		_, err := tag.WriteTo(w)
		if err != nil {
			w.CloseWithError(err)
		} else {
			w.Close()
		}
	}(w)
	return r
}
func (tag Tr) String() string {
	b := strings.Builder{}
	tag.WriteTo(&b)
	return b.String()
}
func (tag Tr) Bytes() []byte {
	b := bytes.Buffer{}
	tag.WriteTo(&b)
	return b.Bytes()
}


type Track baseAttrs

func (tag Track) WriteTo(w io.Writer) (int64, error) {
	n := int64(0)

	nn, err := toInt64Error(fmt.Fprintf(w, "<track"))
	n += int64(nn)
	if err != nil {
		return n, err
	}

	nn, err = baseAttrs(tag).WriteTo(w)
	n += nn
	if err != nil {
		return n, err
	}

	nn, err = toInt64Error(fmt.Fprintf(w, "/>"))
	n += int64(nn)
	return n, err
}
func (tag Track) element() {}
func (tag Track) Reader() io.Reader {
	r, w := io.Pipe()
	go func(w *io.PipeWriter) {
		_, err := tag.WriteTo(w)
		if err != nil {
			w.CloseWithError(err)
		} else {
			w.Close()
		}
	}(w)
	return r
}
func (tag Track) String() string {
	b := strings.Builder{}
	tag.WriteTo(&b)
	return b.String()
}
func (tag Track) Bytes() []byte {
	b := bytes.Buffer{}
	tag.WriteTo(&b)
	return b.Bytes()
}


type U []any

func (tag U) WriteTo(w io.Writer) (int64, error) {
	n := int64(0)

	nn, err := fmt.Fprintf(w, "<u")
	n += int64(nn)
	if err != nil {
		return n, err
	}

	children := len(tag) > 0
	idx := 0

	if children {
		slices.SortStableFunc(tag, sort)
		idx = slices.IndexFunc(tag, index)

		if idx >= 0 {
			for _, attr := range tag[:idx] {
				nn, err := attr.(io.WriterTo).WriteTo(w)
				n += nn
				if err != nil {
					return n, err
				}
			}
		} else {
			for _, attr := range tag {
				nn, err := attr.(io.WriterTo).WriteTo(w)
				n += nn
				if err != nil {
					return n, err
				}
			}
		}
	}

	nn, err = fmt.Fprintf(w, ">")
	n += int64(nn)
	if err != nil {
		return n, err
	}

	if children && idx >= 0 {
		for _, child := range tag[idx:] {
			nn, err := render(w, child)
			n += nn
			if err != nil {
				return n, err
			}
		}
	}

	nn, err = fmt.Fprintf(w, "</u>")
	n += int64(nn)

	return n, nil
}
func (tag U) element() {}
func (tag U) Reader() io.Reader {
	r, w := io.Pipe()
	go func(w *io.PipeWriter) {
		_, err := tag.WriteTo(w)
		if err != nil {
			w.CloseWithError(err)
		} else {
			w.Close()
		}
	}(w)
	return r
}
func (tag U) String() string {
	b := strings.Builder{}
	tag.WriteTo(&b)
	return b.String()
}
func (tag U) Bytes() []byte {
	b := bytes.Buffer{}
	tag.WriteTo(&b)
	return b.Bytes()
}


type Ul []any

func (tag Ul) WriteTo(w io.Writer) (int64, error) {
	n := int64(0)

	nn, err := fmt.Fprintf(w, "<ul")
	n += int64(nn)
	if err != nil {
		return n, err
	}

	children := len(tag) > 0
	idx := 0

	if children {
		slices.SortStableFunc(tag, sort)
		idx = slices.IndexFunc(tag, index)

		if idx >= 0 {
			for _, attr := range tag[:idx] {
				nn, err := attr.(io.WriterTo).WriteTo(w)
				n += nn
				if err != nil {
					return n, err
				}
			}
		} else {
			for _, attr := range tag {
				nn, err := attr.(io.WriterTo).WriteTo(w)
				n += nn
				if err != nil {
					return n, err
				}
			}
		}
	}

	nn, err = fmt.Fprintf(w, ">")
	n += int64(nn)
	if err != nil {
		return n, err
	}

	if children && idx >= 0 {
		for _, child := range tag[idx:] {
			nn, err := render(w, child)
			n += nn
			if err != nil {
				return n, err
			}
		}
	}

	nn, err = fmt.Fprintf(w, "</ul>")
	n += int64(nn)

	return n, nil
}
func (tag Ul) element() {}
func (tag Ul) Reader() io.Reader {
	r, w := io.Pipe()
	go func(w *io.PipeWriter) {
		_, err := tag.WriteTo(w)
		if err != nil {
			w.CloseWithError(err)
		} else {
			w.Close()
		}
	}(w)
	return r
}
func (tag Ul) String() string {
	b := strings.Builder{}
	tag.WriteTo(&b)
	return b.String()
}
func (tag Ul) Bytes() []byte {
	b := bytes.Buffer{}
	tag.WriteTo(&b)
	return b.Bytes()
}


type Var []any

func (tag Var) WriteTo(w io.Writer) (int64, error) {
	n := int64(0)

	nn, err := fmt.Fprintf(w, "<var")
	n += int64(nn)
	if err != nil {
		return n, err
	}

	children := len(tag) > 0
	idx := 0

	if children {
		slices.SortStableFunc(tag, sort)
		idx = slices.IndexFunc(tag, index)

		if idx >= 0 {
			for _, attr := range tag[:idx] {
				nn, err := attr.(io.WriterTo).WriteTo(w)
				n += nn
				if err != nil {
					return n, err
				}
			}
		} else {
			for _, attr := range tag {
				nn, err := attr.(io.WriterTo).WriteTo(w)
				n += nn
				if err != nil {
					return n, err
				}
			}
		}
	}

	nn, err = fmt.Fprintf(w, ">")
	n += int64(nn)
	if err != nil {
		return n, err
	}

	if children && idx >= 0 {
		for _, child := range tag[idx:] {
			nn, err := render(w, child)
			n += nn
			if err != nil {
				return n, err
			}
		}
	}

	nn, err = fmt.Fprintf(w, "</var>")
	n += int64(nn)

	return n, nil
}
func (tag Var) element() {}
func (tag Var) Reader() io.Reader {
	r, w := io.Pipe()
	go func(w *io.PipeWriter) {
		_, err := tag.WriteTo(w)
		if err != nil {
			w.CloseWithError(err)
		} else {
			w.Close()
		}
	}(w)
	return r
}
func (tag Var) String() string {
	b := strings.Builder{}
	tag.WriteTo(&b)
	return b.String()
}
func (tag Var) Bytes() []byte {
	b := bytes.Buffer{}
	tag.WriteTo(&b)
	return b.Bytes()
}


type Video []any

func (tag Video) WriteTo(w io.Writer) (int64, error) {
	n := int64(0)

	nn, err := fmt.Fprintf(w, "<video")
	n += int64(nn)
	if err != nil {
		return n, err
	}

	children := len(tag) > 0
	idx := 0

	if children {
		slices.SortStableFunc(tag, sort)
		idx = slices.IndexFunc(tag, index)

		if idx >= 0 {
			for _, attr := range tag[:idx] {
				nn, err := attr.(io.WriterTo).WriteTo(w)
				n += nn
				if err != nil {
					return n, err
				}
			}
		} else {
			for _, attr := range tag {
				nn, err := attr.(io.WriterTo).WriteTo(w)
				n += nn
				if err != nil {
					return n, err
				}
			}
		}
	}

	nn, err = fmt.Fprintf(w, ">")
	n += int64(nn)
	if err != nil {
		return n, err
	}

	if children && idx >= 0 {
		for _, child := range tag[idx:] {
			nn, err := render(w, child)
			n += nn
			if err != nil {
				return n, err
			}
		}
	}

	nn, err = fmt.Fprintf(w, "</video>")
	n += int64(nn)

	return n, nil
}
func (tag Video) element() {}
func (tag Video) Reader() io.Reader {
	r, w := io.Pipe()
	go func(w *io.PipeWriter) {
		_, err := tag.WriteTo(w)
		if err != nil {
			w.CloseWithError(err)
		} else {
			w.Close()
		}
	}(w)
	return r
}
func (tag Video) String() string {
	b := strings.Builder{}
	tag.WriteTo(&b)
	return b.String()
}
func (tag Video) Bytes() []byte {
	b := bytes.Buffer{}
	tag.WriteTo(&b)
	return b.Bytes()
}


type Wbr baseAttrs

func (tag Wbr) WriteTo(w io.Writer) (int64, error) {
	n := int64(0)

	nn, err := toInt64Error(fmt.Fprintf(w, "<wbr"))
	n += int64(nn)
	if err != nil {
		return n, err
	}

	nn, err = baseAttrs(tag).WriteTo(w)
	n += nn
	if err != nil {
		return n, err
	}

	nn, err = toInt64Error(fmt.Fprintf(w, "/>"))
	n += int64(nn)
	return n, err
}
func (tag Wbr) element() {}
func (tag Wbr) Reader() io.Reader {
	r, w := io.Pipe()
	go func(w *io.PipeWriter) {
		_, err := tag.WriteTo(w)
		if err != nil {
			w.CloseWithError(err)
		} else {
			w.Close()
		}
	}(w)
	return r
}
func (tag Wbr) String() string {
	b := strings.Builder{}
	tag.WriteTo(&b)
	return b.String()
}
func (tag Wbr) Bytes() []byte {
	b := bytes.Buffer{}
	tag.WriteTo(&b)
	return b.Bytes()
}

