// Code generated by github.com/Gardego5/gohtml/codegen; DO NOT EDIT.

package html

import (
	"bytes"
	"io"
	"fmt"
	"slices"
	"strings"
)

func sort(a any, b any) int {
	_, aOk := a.(attr)
	_, bOk := b.(attr)

	if aOk && !bOk {
		return -1
	} else if !aOk && bOk {
		return 1
	} else {
		return 0
	}
}

func index(t any) bool {
	_, ok := t.(attr)
	return !ok
}

func toInt64Error(n int, err error) (int64, error) {
	return int64(n), err
}
{{range .}}
{{if .Desc}}// {{.Desc}}{{end}}
type {{.Name | Title}} {{if .Void}}baseAttrs{{else}}[]any{{end}}
{{if .Void}}
func (tag {{.Name | Title}}) WriteTo(w io.Writer) (int64, error) {
	n := int64(0)

	nn, err := toInt64Error(fmt.Fprintf(w, "<{{.Name}}"))
	n += int64(nn)
	if err != nil {
		return n, err
	}

	nn, err = baseAttrs(tag).WriteTo(w)
	n += nn
	if err != nil {
		return n, err
	}

	nn, err = toInt64Error(fmt.Fprintf(w, "/>"))
	n += int64(nn)
	return n, err
}{{else}}
func (tag {{.Name | Title}}) WriteTo(w io.Writer) (int64, error) {
	n := int64(0)

	nn, err := fmt.Fprintf(w, "<{{.Name}}")
	n += int64(nn)
	if err != nil {
		return n, err
	}

	children := len(tag) > 0
	idx := 0

	if children {
		slices.SortStableFunc(tag, sort)
		idx = slices.IndexFunc(tag, index)

		if idx >= 0 {
			for _, attr := range tag[:idx] {
				nn, err := attr.(io.WriterTo).WriteTo(w)
				n += nn
				if err != nil {
					return n, err
				}
			}
		} else {
			for _, attr := range tag {
				nn, err := attr.(io.WriterTo).WriteTo(w)
				n += nn
				if err != nil {
					return n, err
				}
			}
		}
	}

	nn, err = fmt.Fprintf(w, ">")
	n += int64(nn)
	if err != nil {
		return n, err
	}

	if children && idx >= 0 {
		for _, child := range tag[idx:] {
			nn, err := render(w, child)
			n += nn
			if err != nil {
				return n, err
			}
		}
	}

	nn, err = fmt.Fprintf(w, "</{{.Name}}>")
	n += int64(nn)

	return n, nil
}{{end}}
func (tag {{.Name | Title}}) element() {}
func (tag {{.Name | Title}}) Reader() io.Reader {
	r, w := io.Pipe()
	go func(w *io.PipeWriter) {
		_, err := tag.WriteTo(w)
		if err != nil {
			w.CloseWithError(err)
		} else {
			w.Close()
		}
	}(w)
	return r
}
func (tag {{.Name | Title}}) String() string {
	b := strings.Builder{}
	tag.WriteTo(&b)
	return b.String()
}
func (tag {{.Name | Title}}) Bytes() []byte {
	b := bytes.Buffer{}
	tag.WriteTo(&b)
	return b.Bytes()
}
{{end}}
